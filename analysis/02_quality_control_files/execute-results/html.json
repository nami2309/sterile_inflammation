{
  "hash": "dca8b52f73f1cd1318aff01f261631f2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Quality control\"\nformat:\n  html:\n    theme: Default\n    toc: true\n    code-fold: true\nexecute:\n  echo: true\n  warning: false\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Define sample names\nsample_names <- c(\"PVM_0h\", \"PVEU_0h\", \"PVM_4h\", \"PVEU_4h\", \"PVM_7h\", \"PVEU_7h\")\n\nsample_colors <- c(\n  \"PVM_0h\"  = \"#EE9A49\",  \n  \"PVM_4h\"  = \"#CD853F\", \n  \"PVM_7h\" = \"#8B5A2B\",  \n  \"PVEU_0h\"  = \"#7EC0EE\",\n  \"PVEU_4h\" = \"#6CA6CD\", \n  \"PVEU_7h\" = \"#4A708B\"\n)\n\nscript_number <- \"02_\"\nproject <- \"SI\"\ntag <- paste0(script_number,project)\n\nproj_dir <- \"/Users/nami/Desktop/sterile_inflammation\"\nsobj_dir <- \"/Users/nami/Desktop/sterile_inflammation/output/processed/\"\nbpparam <- BiocParallel::MulticoreParam(workers = 6)\noptions(future.globals.maxSize = 30 * 1024^3)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# scRNA-seq\nlibrary(\"SingleCellExperiment\")\n# library(\"scater\")\n# library(\"scran\")\nlibrary(Seurat)\n#library(singleCellTK)\n\n# RNA-seq\n#library(\"edgeR\")\n\n# Plotting\nlibrary(\"cowplot\")\nlibrary(\"gridExtra\")\nlibrary(patchwork)\n\n# Tidyverse\nlibrary(\"tidyverse\")\n\nlibrary(here)\n#library(\"variancePartition\")\nlibrary(tidyr)\nlibrary(dplyr)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsource(paste0(proj_dir, \"/functions/universal.R\"))\n```\n:::\n\n\n\n\n# Introduction\n\nIn this document we are going to explore the dataset and filter it to remove low quality cells and lowly expressed genes. The goal is to have a high quality dataset that can be used for further analysis.\n\nFirst we will use size factors to normalize raw counts across cells to account for differences in sequencing depth or library size. Library size is the total number of counts (UMIs or reads) observed for a cell. Size factors are calc based on the total counts (library size) for each cell in the dataset. Cells with larger library sizes get higher size factors, and vice versa. Library size factors can differ by up to 10-fold across cells. This is typical of the variability in coverage in scRNA-seq data (see histogram below).\n\nNormalizing by size factors ensures that comparisons of gene expression across cells are not biased by variations in sequencing depth. We will plot library sizes against normalized counts to ensure that library sizes no longer drive the expression levels.\n\nWe will then create a Seurat object with the cell barcodes that were found to be not empty droplets from our previous analysis. After normalizing, we will check that the normalized counts vs lib size in the seurat object recapitulate the findings in the SCE object. Once done, we will perform QC and PCA, and calculate tSNE and UMAP embeddings.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nload(paste0(proj_dir, \"/output/processed/01_SI_selected.Robj\"))\n\nset.seed(1)\nsizeFactors(selected) <- librarySizeFactors(selected)\n# summary(sizeFactors(selected))\n# summary(colSums(counts(selected)))\n# plot(sizeFactors(selected), colSums(counts(selected)), log = \"xy\",\n#      xlab = \"Size factor\", ylab = \"Library size\",\n#      main = \"Size factors vs library size\")\n# abline(0, 1, col = \"red\")\n\nselected <- logNormCounts(selected)\n#02_SI_selected.Robj---------\nsave(selected, file=here::here(\"output/processed/02_SI_selected.Robj\"))\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nload(paste0(proj_dir, \"/output/processed/02_SI_selected.Robj\"))\n\n#Define sample names and file paths\nsample_names <- c(\"PVM_0h\", \"PVEU_0h\", \"PVM_4h\", \"PVEU_4h\", \"PVM_7h\", \"PVEU_7h\")\nfile_paths <- paste0(\"/Users/nami/Desktop/sterile_inflammation/data/cellranger_results/\", sample_names, \"/raw_feature_bc_matrix\")\n\n# Initialize a list to store Seurat objects\nseurat_list <- list()\n\n# Loop through each sample to read data and create Seurat objects\nfor (i in 1:length(sample_names)) {\n  data <- Read10X(data.dir = file_paths[i])\n  sobj <- CreateSeuratObject(counts = data, project = sample_names[i], min.cells = 0, min.features = 0)\n  sobj$sample <- sample_names[i]  # Add sample information\n  seurat_list[[sample_names[i]]] <- sobj\n}\n\n# Add metadata\nfor (sample in sample_names) {\n  sobj <- seurat_list[[sample]]\n  # Extract time point from sample name\n  time_point <- sub(\".*_(\\\\d+h).*\", \"\\\\1\", sample)\n  # Assign condition based on time point\n  condition <- ifelse(time_point == \"0h\", \"Control\", \"Post-TNFa\")\n  sobj$time_point <- time_point\n  sobj$condition <- condition\n  seurat_list[[sample]] <- sobj\n}\n\n# Loop over each sample name in the seurat_list to seperate them\nfor (sample_name in names(seurat_list)) {\n  # Extract the Seurat object from the list\n  sobj <- seurat_list[[sample_name]]\n  \n  # Assign the Seurat object to a variable with the sample name\n  assign(sample_name, sobj)\n}\n\nremove(sobj, data)\n\n# Combine seurat objects\nsobjects <- list(\n  PVM_0h = PVM_0h,\n  PVEU_0h = PVEU_0h,\n  PVM_4h = PVM_4h,\n  PVEU_4h = PVEU_4h,\n  PVM_7h = PVM_7h,\n  PVEU_7h = PVEU_7h\n)\n\n# Ensure the names correspond to sample names\nsample_names <- names(sobjects)\n\n# Append sample name as a prefix to each cell ID\nsobjects <- mapply(function(obj, sample_name) {\n  # Create new cell IDs by concatenating sample name and original cell ID\n  new_cell_ids <- paste0(sample_name, \"_\", colnames(obj))\n  \n  # Assign the new cell IDs to the Seurat object\n  colnames(obj) <- new_cell_ids\n  \n  # Return the modified Seurat object\n  return(obj)\n}, sobjects, names(sobjects), SIMPLIFY = FALSE)\n\n\n# Merge all Seurat objects with sample-specific prefixes\nsobj <- sobjects[[1]]\n\n# Iteratively merge the remaining Seurat objects\nfor (i in 2:length(sobjects)) {\n  sobj <- merge(sobj, y = sobjects[[i]])\n}\n\nsobj <- JoinLayers(sobj)\nsobj\n# An object of class Seurat\n# 20495 features across 44902 samples within 1 assay\n# Active assay: RNA (20495 features, 0 variable features)\n# 1 layer present: counts\n\ntable(sobj$orig.ident)\n# PVEU_0h PVEU_4h PVEU_7h  PVM_0h  PVM_4h  PVM_7h\n# 8642    9076    8841    5800    6853    5690\n\n# Check integrity of obj\n# List the assays present in the Seurat object\nAssays(sobj)\n\n# Check the default assay\nDefaultAssay(sobj)\n\n# Check if the main assay (e.g., RNA) exists and is non-empty\nsobj[[\"RNA\"]]\n\n# Verify the structure of the merged object\nstr(sobj)\n\n# Check the first few cell IDs\nhead(colnames(sobj))\n\n# Extract columns from SCE metadata\nsce_metadata <- data.frame(\n  Sample = colnames(selected),  # Extract cell barcodes\n  CellBarcode = selected@colData@listData[[\"Barcode\"]],\n  CellRangerFilt = selected@colData@listData[[\"CellRangerFilt\"]],\n  EmpDropsFilt = selected@colData@listData[[\"EmpDropsFilt\"]],\n  SelMethod = selected@colData@listData[[\"SelMethod\"]]\n)\n\n# Check the updated CellBarcode values\nhead(sce_metadata$CellBarcode)\n\n# Add prefix to CellBarcode\nsce_metadata$CellBarcode <- paste0(\n  str_extract(sce_metadata$Sample, \"^[^_]*_[^_]*\"), # Extract everything before the 2nd underscore\n  \"_\",\n  sce_metadata$CellBarcode # Append original CellBarcode\n)\nsce_metadata$CellBarcode\n\n# Preview the modified column\nhead(sce_metadata$CellBarcode)\n\n# Subset the Seurat object to include only the common barcodes\ncommon_barcodes <- sce_metadata$CellBarcode\nsobj <- subset(sobj, cells = common_barcodes)\ndim(sobj)  \n\n# Add metadata to Seurat object\n# Ensure matching by CellBarcode\nrownames(sce_metadata) <- sce_metadata$CellBarcode\nsobj <- AddMetaData(sobj, metadata = sce_metadata)\n\n# Calculate percentage of mitochondrial genes\nsobj[[\"percent.mt\"]] <- PercentageFeatureSet(object = sobj, pattern = \"^mt-\")\n\n# Add number of genes per UMI for each cell to metadata\nsobj$log10genes_per_UMI <- log10(sobj$nFeature_RNA) / log10(sobj$nCount_RNA)\n\nsobj@meta.data <- sobj@meta.data %>%\n  select(-Sample, -CellBarcode)\n\n# Modify the \"sample\" column in the meta.data slot\nsobj@meta.data[[\"sample\"]] <- gsub(\"_.*$\", \"\", sobj@meta.data[[\"sample\"]])\n\n# Verify the changes\nhead(sobj@meta.data[[\"sample\"]])\n\n#02_SI_sobj.Robj---------\nsave(sobj, file=\"/home/nsingh/sterile_inflammation/output/processed/02_SI_sobj.Robj\")\n\n# Normalize and scale\nsobj <- NormalizeData(\n  object = sobj,\n  normalization.method = \"LogNormalize\", # Log-normalization\n  scale.factor = 10000                   # Scaling factor\n)\nsobj <- ScaleData(sobj)\n#02_SI_sobj_scale.Robj---------\nsave(sobj, file=\"/home/nsingh/sterile_inflammation/output/processed/02_SI_sobj_scale.Robj\")\n```\n:::\n\n\n\n\n## Check lib size vs normalization\n\n::: panel-tabset\n### SCE {.unnumbered}\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nload(paste0(proj_dir, \"/output/processed/02_SI_selected.Robj\"))\nhist(log10(sizeFactors(selected)), xlab=\"Log10[sizeFactors]\", col='grey80')\nlibrary_sizes <- colSums(counts(selected))\nmean_logcounts <- colMeans(assay(selected, \"logcounts\"))\nplot(log10(library_sizes), mean_logcounts, \n     xlab = \"Log10 library size\", ylab = \"Mean log-normalized counts\",\n     main = \"Normalized counts vs library size\")\nabline(h = median(mean_logcounts), col = \"red\", lty = 2)\nrm(selected)\n```\n:::\n\n\n\n\n![](../output/plots/02_quality_control/02_SI_1_lib_size_vs_norm_counts-1.png)\n\n![](../output/plots/02_quality_control/02_SI_1_lib_size_vs_norm_counts-2.png)\n\n### Seurat {.unnumbered}\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nload(paste0(proj_dir, \"/output/processed/02_SI_sobj_scale.Robj\"))\n# Extract library sizes\nlibrary_sizes <- colSums(sobj@assays$RNA$counts)\n\n# Extract normalized data means\nmean_logcounts <- Matrix::colMeans(sobj@assays$RNA$data)\n\n# Plot size factors vs library sizes\nplot(log10(library_sizes), mean_logcounts,\n     xlab = \"Log10 library size\",\n     ylab = \"Mean log-normalized counts\",\n     main = \"Normalized counts vs library size\")\nabline(h = median(mean_logcounts), col = \"red\", lty = 2)\n```\n:::\n\n\n\n\n![](../output/plots/02_quality_control/02_SI_2_check_normalization_in_so-1.png)\n:::\n\n# Exploration\n\nWe will start off by making some plots to explore the dataset.\n\n## Expression by cell - MADs\n\nDistributions by cell. Blue line shows the median and red lines show median absolute deviations (MADs) from the median.\n\n::: panel-tabset\n### Total counts {.unnumbered}\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nload(paste0(proj_dir, \"/output/processed/02_SI_sobj_scale.Robj\"))\noutlierHistogramSeurat(sobj, feature=\"nCount_RNA\", mads = 1:6)\n```\n:::\n\n\n\n\n![](../output/plots/02_quality_control/02_SI_3_counts_MADs-1.png)\n\n### Total features {.unnumbered}\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\noutlierHistogramSeurat(sobj, feature=\"nFeature_RNA\", mads = 1:6)\n```\n:::\n\n\n\n\n![](../output/plots/02_quality_control/02_SI_4_features_MADs-1.png)\n\n### Percent mitochondrial {.unnumbered}\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\noutlierHistogramSeurat(sobj, feature=\"percent.mt\", mads = 1:6)\n```\n:::\n\n\n\n\n![](../output/plots/02_quality_control/02_SI_5_percentmt_MADs-1.png)\n:::\n\n## Expression by cell - manual\n\n::: panel-tabset\n### nCount_RNA {.unnumbered}\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\np1 <- VlnPlot(sobj, \n              features = c(\"nCount_RNA\"), \n              ncol = 1, \n              assay = \"RNA\", \n              group.by = \"orig.ident\",\n              cols = sample_colors, \n              stack = FALSE) & geom_hline(yintercept =500, col=\"blue\") \n              annotate(\"text\", x=0.5, y=1000, label=\"      500\", size=2,color = \"blue\")\n\n# Visualize the number UMIs/transcripts per cell\n# UMI count should be above 500 low-end, expected\n# between 500-1000 counts, usable should have been sequenced more deeply\np2 <- sobj@meta.data %>% \n  ggplot(aes(color=orig.ident, x=nCount_RNA, fill= orig.ident)) + \n  geom_density(alpha = 0.2) + \n  scale_x_log10() + \n  theme_classic() +\n  ylab(\"Cell density\") +\n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) + \n  geom_vline(xintercept = 500)\n  NoLegend()\n\n# FeatureScatter plot for nCount_RNA vs nFeature_RNA\n# Generate the FeatureScatter plot as a ggplot object\np3 <- FeatureScatter(\n    object = sobj, \n    group.by = \"orig.ident\",\n    split.by = NULL,\n    feature1 = \"nCount_RNA\", \n    cols = sample_colors,\n    feature2 = \"nFeature_RNA\", \n    shuffle = TRUE, \n    plot.cor = FALSE\n)\n\np3 <- p3 + \n    geom_vline(xintercept = 500, color = \"blue\", linetype = \"dashed\") + \n    geom_hline(yintercept = 300, color = \"blue\", linetype = \"dashed\") + \n    annotate(\"text\", x = 500, y = 4000, \n             label = \"500\", color = \"blue\", vjust = -0.5, hjust = -0.1, angle = 90) +\n    annotate(\"text\", x = 30000, y = 300, \n             label = \"300\", color = \"blue\", vjust = -0.5, hjust = -0.1)\n\n# FeatureScatter plot for nCount_RNA vs percent.mt\np4 <- FeatureScatter(\n    object = sobj, \n    group.by = \"orig.ident\",\n    split.by = NULL,\n    feature1 = \"nCount_RNA\", \n    cols = sample_colors,\n    feature2 = \"percent.mt\", \n    shuffle = TRUE, \n    plot.cor = FALSE\n)  \n\np4 <- p4 + \n    geom_vline(xintercept = 500, color = \"blue\", linetype = \"dashed\") + \n    geom_hline(yintercept = 5, color = \"red\", linetype = \"dashed\") + \n    annotate(\"text\", x = 500, y = 75, \n             label = \"500\", color = \"blue\", vjust = -0.5, hjust = -0.1, angle = 90) +\n    annotate(\"text\", x = 30000, y = 5, \n             label = \"5%\", color = \"red\", vjust = -0.5, hjust = -0.1)\n\n# Visualize the correlation between genes detected and number of UMIs and determine whether strong presence of cells with low numbers of genes/UMIs\n# poor quality cells likely to have low genes & UMIs per cell\np5 <- sobj@meta.data %>% \n  ggplot(aes(x=nCount_RNA, y=nFeature_RNA, color=percent.mt)) + \n  geom_point() + \n  scale_colour_gradient(low = \"gray90\", high = \"black\") +\n  stat_smooth(method=lm) +\n  scale_x_log10() + \n  scale_y_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 500) +\n  geom_hline(yintercept = 250) +\n  facet_wrap(~orig.ident)\n\np <- p1 + p2 + p3 + p4 + p5 + plot_layout(\n    ncol = 2, guides = \"collect\") + plot_annotation(\n        title = \"Before filtering\", \n        tag_levels = \"A\")\np\n```\n:::\n\n\n\n\n![](../output/plots/02_quality_control/02_SI_6_nCount_RNA_before_filt-1.png)\n\n### nFeature_RNA {.unnumbered}\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\np1 <- VlnPlot(sobj, \n              features = c(\"nFeature_RNA\"), \n              ncol = 1, assay = \"RNA\", \n              group.by = \"orig.ident\", \n              cols = sample_colors, \n              stack = FALSE) & geom_hline(yintercept =300, col=\"blue\") & #geom_hline(yintercept = 3500, col=\"red\") & \n              annotate(\"text\", x=0.5, y=400, label=\"    300\", size=2,color = \"blue\") #& \n              #annotate(\"text\", x=0.5, y=3600, label=\"    3500\", size=2,color = \"red\") \n# Visualize the distribution of genes detected per cell via histogram\n# single peak represents cells encapsulated\n# shoulder/bimodal distribution: 1.cells that failed, 2. biologically different types (quiescent cells, less complex cells,size)\np2 <- sobj@meta.data %>% \n  ggplot(aes(color=orig.ident, x=nFeature_RNA, fill= orig.ident)) + \n  geom_density(alpha = 0.2) + \n  theme_classic() +\n  scale_x_log10() + \n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) + #geom_vline(xintercept = 3500) +\n  geom_vline(xintercept = 300) & NoLegend()#cutoff at >400 ?\n\np3 <- FeatureScatter(object = sobj, \n                        group.by = \"orig.ident\",\n                        split.by = NULL,\n                        feature1 = \"nCount_RNA\", \n                        cols = sample_colors,\n                        feature2 = \"nFeature_RNA\", \n        shuffle = TRUE, plot.cor = FALSE)  & NoLegend()\np3 <- p3 + \n    geom_vline(xintercept = 500, color = \"blue\", linetype = \"dashed\") + \n    geom_hline(yintercept = 300, color = \"blue\", linetype = \"dashed\") + \n    annotate(\"text\", x = 500, y = 4000, \n             label = \"500\", color = \"blue\", vjust = -0.5, hjust = -0.1, angle = 90) +\n    annotate(\"text\", x = 30000, y = 300, \n             label = \"300\", color = \"blue\", vjust = -0.5, hjust = -0.1)\n\np4 <- FeatureScatter(object = sobj, \n                        group.by = \"orig.ident\",\n                        split.by = NULL,\n                        feature1 = \"nFeature_RNA\", \n                        cols = sample_colors,\n                        feature2 = \"percent.mt\", \n        shuffle = TRUE, plot.cor = FALSE)  & NoLegend()\np4 <- p4 + \n    geom_vline(xintercept = 300, color = \"blue\", linetype = \"dashed\") + \n    geom_hline(yintercept = 5, color = \"red\", linetype = \"dashed\") + \n    annotate(\"text\", x = 300, y = 75, \n             label = \"300\", color = \"blue\", vjust = -0.5, hjust = -0.1, angle = 90) +\n    annotate(\"text\", x = 30000, y = 5, \n             label = \"5%\", color = \"red\", vjust = -0.5, hjust = -0.1)\n\n# Visualize the correlation between genes detected and number of UMIs and determine whether strong presence of cells with low numbers of genes/UMIs\n# poor quality cells likely to have low genes & UMIs per cell\np5 <- sobj@meta.data %>% \n  ggplot(aes(x=nCount_RNA, y=nFeature_RNA, color=percent.mt)) + \n  geom_point() + \n  scale_colour_gradient(low = \"gray90\", high = \"black\") +\n  stat_smooth(method=lm) +\n  scale_x_log10() + \n  scale_y_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 500) +\n  geom_hline(yintercept = 250) +\n  facet_wrap(~orig.ident)\n\np <- p1 + p2 + p3 + p4 + p5 + plot_layout(\n    ncol = 2, guides = \"collect\") + plot_annotation(\n        title = \"Before filtering\", \n        tag_levels = \"A\")\np\n```\n:::\n\n\n\n\n![](../output/plots/02_quality_control/02_SI_7_nFeature_RNA_before_filt-1.png)\n\n### Percent mitochondrial {.unnumbered}\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Visualize the distribution of mitochondrial gene expression detected per cell\n# indication if there's large amount of mito-contamination f. dead/dying cells, above 0.2 mito ratio mark poor quality, unless expected differently \np1 <- VlnPlot(sobj, \n              features = c(\"percent.mt\"), \n              ncol = 1, \n              assay = \"RNA\", \n              group.by = \"orig.ident\", \n              cols = sample_colors, \n              stack = FALSE) & geom_hline(yintercept = 5, col=\"red\")& \n              annotate(\"text\", x=0.5, y=13, label=\"     5%\", size=3,color = \"red\") \n\np2 <-sobj@meta.data %>%\n  ggplot(aes(color=orig.ident, x=percent.mt, fill=orig.ident)) + \n  geom_density(alpha = 0.2) + \n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) +\n  scale_x_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 5) & NoLegend()\n\n# FeatureScatter plot for nCount_RNA vs percent.mt\np3 <- FeatureScatter(\n    object = sobj, \n    group.by = \"orig.ident\",\n    split.by = NULL,\n    feature1 = \"nCount_RNA\", \n    cols = sample_colors,\n    feature2 = \"percent.mt\", \n    shuffle = TRUE, \n    plot.cor = FALSE\n)  \n\np3 <- p3 + \n    geom_vline(xintercept = 500, color = \"blue\", linetype = \"dashed\") + \n    geom_hline(yintercept = 5, color = \"red\", linetype = \"dashed\") + \n    annotate(\"text\", x = 500, y = 75, \n             label = \"500\", color = \"blue\", vjust = -0.5, hjust = -0.1, angle = 90) +\n    annotate(\"text\", x = 30000, y = 5, \n             label = \"5%\", color = \"red\", vjust = -0.5, hjust = -0.1)\n\np4 <- FeatureScatter(object = sobj, \n                        group.by = \"orig.ident\",\n                        split.by = NULL,\n                        feature1 = \"nFeature_RNA\", \n                        cols = sample_colors,\n                        feature2 = \"percent.mt\", \n        shuffle = TRUE, plot.cor = FALSE)  & NoLegend()\np4 <- p4 + \n    geom_vline(xintercept = 300, color = \"blue\", linetype = \"dashed\") + \n    geom_hline(yintercept = 5, color = \"red\", linetype = \"dashed\") + \n    annotate(\"text\", x = 300, y = 75, \n             label = \"300\", color = \"blue\", vjust = -0.5, hjust = -0.1, angle = 90) +\n    annotate(\"text\", x = 30000, y = 5, \n             label = \"5%\", color = \"red\", vjust = -0.5, hjust = -0.1)\n\np <- p1 + p2 + p3 + p4 + plot_layout(\n    ncol = 2, guides = \"collect\") + plot_annotation(\n        title = \"Before filtering\", \n        tag_levels = \"A\")\np\n```\n:::\n\n\n\n\n![](../output/plots/02_quality_control/02_SI_8_percentmt_before_filt-1.png)\n\n### Log10 genes per UMI {.unnumbered}\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\np1 <- VlnPlot(sobj, \n              features = c(\"log10genes_per_UMI\"), \n              ncol = 1, \n              assay = \"RNA\", \n              group.by = \"orig.ident\", \n              cols = sample_colors, \n              stack = FALSE) & geom_hline(yintercept = 0.8, col=\"blue\") & \n              annotate(\"text\", x=0.7, y=0.81, label=\"0.8\", size=3,color = \"blue\")  \n\n# Visualize the overall complexity of the gene expression by visualizing the genes detected per UMI\n# novelty score: ratio Genes/UMI\n# highUMI & low Genes = only little genes, sequences over again == low complexity/novelty; associated to cell type? or  artifact?\n# above 0.8\np2 <- sobj@meta.data %>%\n  ggplot(aes(x=log10genes_per_UMI, color = orig.ident, fill=orig.ident)) +\n  geom_density(alpha = 0.2) +\n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) +\n  theme_classic() +\n  geom_vline(xintercept = 0.8) & NoLegend()\n\np <- p1 + p2 + plot_layout(\n    ncol = 2, guides = \"collect\") + plot_annotation(\n        title = \"Before filtering\", \n        tag_levels = \"A\")\np\nrm(sobj)\n```\n:::\n\n\n\n\n![](../output/plots/02_quality_control/02_SI_9_log10genes_before_filt-1.png)\n:::\n\n# Filtering #1\n\nThis is according to the previous plots. **Following parameters were used for filtering:**\n\n1.  300 \\< nFeature_RNA\n\n2.  500 \\< nCountRNA\n\n3.  percent.mt \\< 5%\n\n4.  log10genes_per_UMI \\> 0.8\n\nCells with high nCount_RNA and nFeature_RNA are retained for now as they help in simulating doublets.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfiltered_sobj <- subset(x = sobj,\n                   subset = (nFeature_RNA > 300) & #39911 \n                     #(nFeature_RNA < 4000) & #these cells with high featureRNA are needed to perform doublet identification later\n                     (nCount_RNA > 500) & #39249\n                     #(nCount_RNA < 20000) & \n                     (log10genes_per_UMI > 0.80) & #39231\n                     (percent.mt < 5) #36838\n                     ) \nfiltered_sobj\n#32285 features across 36838 samples within 1 assay \n\n#Remove genes that are not expressed in enough cells to be informative.\n\nlayers <- c(\"counts\")\nall_keep_genes <- list()\n\nfor (layer in layers) {\n      counts <- LayerData(filtered_sobj, assay = \"RNA\", layer = layer)\n      nonzero <- counts > 0\n      keep_genes <- Matrix::rowSums(nonzero) >= 5 #Identifies genes expressed in at least 5 cells.\n     all_keep_genes[[layer]] <- rownames(counts)[keep_genes]\n}\n common_keep_genes <- Reduce(base::intersect, all_keep_genes) #Finds genes that are common across all layers. Since there's only one layer, this is simply the list of genes expressed in at least 5 cells.\n filtered_sobj <- subset(filtered_sobj, features = common_keep_genes)\n\n#Updating Assay Data with Filtered Genes\nfor (layer in layers) {\n   counts <- LayerData(filtered_sobj, assay = \"RNA\", layer = layer)\n   filtered_counts <- counts[common_keep_genes, ]\n  filtered_sobj <- SetAssayData(filtered_sobj, assay = \"RNA\", slot = layer, new.data = filtered_counts)\n}\n \nfiltered_sobj \n#20635 features across 36838 samples within 1 assay \n\n# Normalize and scale\nfiltered_sobj <- NormalizeData(\n  object = filtered_sobj,\n  normalization.method = \"LogNormalize\", # Log-normalization\n  scale.factor = 10000                   # Scaling factor\n)\nfiltered_sobj <- ScaleData(filtered_sobj)\nfiltered_sobj <- FindVariableFeatures(filtered_sobj)\nfiltered_sobj <- RunPCA(filtered_sobj, npcs=50)\nfiltered_sobj <- RunUMAP(filtered_sobj, dims = 1:50)\nfiltered_sobj <- FindNeighbors(filtered_sobj)\nfiltered_sobj <- FindClusters(filtered_sobj)\n#02_SI_sobj_qc.Robj---------\nsave(filtered_sobj, file=\"./output/processed/02_SI_sobj_qc.Robj\")\n```\n:::\n\n\n\n\n## Post filtering #1 QC metrics\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nload(paste0(proj_dir, \"/output/processed/02_SI_sobj_qc.Robj\"))\np1 <- VlnPlot(filtered_sobj, \n              features = c(\"nFeature_RNA\"), \n              ncol = 1, assay = \"RNA\", \n              group.by = \"orig.ident\", \n              cols = sample_colors, \n              stack = FALSE) \np2 <- VlnPlot(filtered_sobj, \n              features = c(\"nCount_RNA\"), \n              ncol = 1, \n              assay = \"RNA\", \n              group.by = \"orig.ident\",\n              cols = sample_colors, \n              stack = FALSE)  \np3 <- VlnPlot(filtered_sobj, \n              features = c(\"percent.mt\"),\n             ncol = 1, \n              assay = \"RNA\", \n              group.by = \"orig.ident\", \n              cols = sample_colors, \n              stack = FALSE) \n\np4 <- VlnPlot(filtered_sobj, \n              features = c(\"log10genes_per_UMI\"), \n              ncol = 1, \n              assay = \"RNA\", \n              group.by = \"orig.ident\", \n              cols = sample_colors, \n              stack = FALSE) \n\n# Visualize the distribution of genes detected per cell via histogram\n  # single peak represents cells encapsulated\n  # shoulder/bimodal distribution: 1.cells that failed, 2. biologically different types (quiescent cells, less complex cells,size)\np5 <- filtered_sobj@meta.data  %>% \n  ggplot(aes(color=orig.ident, x=nFeature_RNA, fill= orig.ident)) + \n  geom_density(alpha = 0.2) + \n  theme_classic() +\n  scale_x_log10() + \n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) + geom_vline(xintercept = 4000) +\n  geom_vline(xintercept = 300) & NoLegend()\n\n\n# Visualize the number UMIs/transcripts per cell\n  # UMI count should be above 500 low-end, expected\n  # between 500-1000 counts, usable should have been sequenced more deeply\np6 <- filtered_sobj@meta.data %>% \n  ggplot(aes(color=orig.ident, x=nCount_RNA, fill= orig.ident)) + \n  geom_density(alpha = 0.2) + \n  scale_x_log10() + \n  theme_classic() +\n  ylab(\"Cell density\") +\n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) + geom_vline(xintercept = 500) + \n  geom_vline(xintercept = 20000) + \n  NoLegend()\n\n# Visualize the distribution of mitochondrial gene expression detected per cell\n  # indication if there's large amount of mito-contamination f. dead/dying cells, above 0.2 mito ratio mark poor quality, unless expected differently \n\np7 <- filtered_sobj@meta.data %>%\n  ggplot(aes(color=orig.ident, x=percent.mt, fill=orig.ident)) + \n  geom_density(alpha = 0.2) + \n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) +\n  scale_x_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 5) & NoLegend()\n\n\n# Visualize the overall complexity of the gene expression by visualizing the genes detected per UMI\n  # novelty score: ratio Genes/UMI\n  # highUMI & low Genes = only little genes, sequences over again == low complexity/novelty; associated to cell type? or  artifact?\n  # above 0.8\np8 <- filtered_sobj@meta.data %>%\n  ggplot(aes(x=log10genes_per_UMI, color = orig.ident, fill=orig.ident)) +\n  geom_density(alpha = 0.2) +\n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) +\n  theme_classic() +\n  geom_vline(xintercept = 0.8) & NoLegend()\n\n\np <- p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8 + plot_layout(\n    ncol = 4, guides = \"collect\") + plot_annotation(\n        title = \"After filtering\", \n        tag_levels = \"A\")\np\nrm(filtered_sobj)\n```\n:::\n\n\n\n\n![](../output/plots/02_quality_control/02_SI_10_post_filtering_qc_metrics-1.png)\n\nWe have removed some extreme outliers but QC is always an iterative process, so we will look at some more factors to ensure only quality cells remain. We will also fine tune QC to set some sample-specific thresholds.\n\n**Cells with high nCount_RNA and nFeature_RNA are retained for now as they help in simulating doublets.**\n\nWe will check for doublets next.\n\n# Doublet finder\n\nAccording to DF Github:\n\n\"Do not apply DoubletFinder to aggregated scRNA-seq data representing multiple distinct samples (e.g., multiple 10X lanes). For example, if you run DoubletFinder on aggregated data representing WT and mutant cell lines sequenced across different 10X lanes, artificial doublets will be generated from WT and mutant cells, which cannot exist in your data. These artificial doublets will skew results. Notably, it is okay to run DoubletFinder on data generated by splitting a single sample across multiple 10X lanes.\"\n\nSince we have 6 distinct samples, it makes sense to run DF seperately on each.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(DoubletFinder)\n\n# Split the Seurat object by sample\nsplit_sobj_list <- SplitObject(filtered_sobj, split.by = \"orig.ident\")\n\n# Prepare a list to store processed objects\nsobj_out_list <- list()\nbcmvn_list <- list()\n\nfor (sample_name in names(split_sobj_list)) {\n  \n  # Extract the subset for this sample\n  sobj_sub <- split_sobj_list[[sample_name]]\n  \n  # --- Preprocessing steps ---\n  sobj_sub <- NormalizeData(sobj_sub)\n  sobj_sub <- FindVariableFeatures(sobj_sub)\n  sobj_sub <- ScaleData(sobj_sub)\n  sobj_sub <- RunPCA(sobj_sub, npcs = 20)\n  sobj_sub <- RunUMAP(sobj_sub, dims = 1:20)\n  sobj_sub <- FindNeighbors(sobj_sub, dims = 1:20)\n  sobj_sub <- FindClusters(sobj_sub, resolution = 0.5)\n  \n  # --- DoubletFinder Param Sweep ---\n  set.seed(123)\n  sweep.res.list <- paramSweep(sobj_sub, PCs = 1:20, sct = FALSE)\n  sweep.stats <- summarizeSweep(sweep.res.list, GT = FALSE)\n  bcmvn <- find.pK(sweep.stats)\n  \n  # Identify the optimal pK\n  optimal_pK <- bcmvn$pK[which.max(bcmvn$BCmetric)]\n  optimal_pK <- as.numeric(as.character(optimal_pK))\n  \n  # Doublet formation rate (example: 1%)\n  nExp_poi <- round(0.05 * nrow(sobj_sub@meta.data))\n  \n  # Run DoubletFinder\n  sobj_sub <- doubletFinder(\n    sobj_sub,\n    PCs        = 1:20,\n    pN         = 0.25,\n    pK         = optimal_pK,\n    nExp       = nExp_poi,\n    reuse.pANN = FALSE,\n    sct        = FALSE\n  )\n  \n  # Rename pANN/doublet classifications for clarity:\n  new_meta_cols <- colnames(sobj_sub@meta.data)\n  pANN_col <- grep(\"pANN\", new_meta_cols, value = TRUE)\n  DF_col   <- grep(\"DF.classifications\", new_meta_cols, value = TRUE)\n  \n  # Store Final Subset Object\n  sobj_out_list[[sample_name]] <- sobj_sub\n  bcmvn_list[[sample_name]] <- bcmvn\n}\n\nsave(sobj_out_list, file=\"./output/processed/02_SI_sobj_df_out_list.Robj\")\nsave(bcmvn_list, file=\"./output/processed/02_SI_bcmvn_df_out_list.Robj\")\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stdout}\n\n```\n## Sample:  PVM_0h  {.tabset}\n\n\n### UMAP: Doublet classification\n\n\n\n## Sample:  PVEU_0h  {.tabset}\n\n\n### UMAP: Doublet classification\n\n\n\n## Sample:  PVM_4h  {.tabset}\n\n\n### UMAP: Doublet classification\n\n\n\n## Sample:  PVEU_4h  {.tabset}\n\n\n### UMAP: Doublet classification\n\n\n\n## Sample:  PVM_7h  {.tabset}\n\n\n### UMAP: Doublet classification\n\n\n\n## Sample:  PVEU_7h  {.tabset}\n\n\n### UMAP: Doublet classification\n```\n\n\n:::\n:::\n\n\n\n\nLets see what these classifications look like on the combined object.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](02_quality_control_files/figure-html/visualize-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n\n# Filtering #2\n\nFrom the findings above, I filtered out the clusters enriched in doublets (clusters 23, 22, 19) and also removed the doublets from other clusters.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Remove doublet enriched clusters\nsobj_post_df <- subset(filtered_sobj, idents = c(23, 22, 19), invert = TRUE)\nsobj_post_df\n#20635 features across 36439 samples within 1 assay\n#651 cells removed\n\n# Remove doublets\nsobj_post_df <- subset(sobj_post_df, subset = DF_by_sample != \"Doublet\")\nsobj_post_df\n#19268 features across 34815 samples within 1 assay\n#1363 cellls removed\n\nDimPlot(sobj_post_df, group.by = \"DF_by_sample\", label = F) +\n  NoAxes() +\n  ggtitle(\"\")\n\n# Remove cells with high count and feature RNA\nsobj_post_df <- subset(x = sobj_post_df,\n                       subset = (nFeature_RNA < 4000)) \n#20635 features across 34698 samples within 1 assay                        \nsobj_post_df <- subset(x = sobj_post_df,\n                       subset = (nCount_RNA < 20000))  \n#20635 features across 34680 samples within 1 assay \n#these cells with high featureRNA were needed to perform doublet identification\n\nsobj_post_df <- NormalizeData(\n  object = sobj_post_df,\n  normalization.method = \"LogNormalize\", # Log-normalization\n  scale.factor = 10000                   # Scaling factor\n)\nsobj_post_df <- ScaleData(sobj_post_df)\nsobj_post_df <- FindVariableFeatures(sobj_post_df)\nsobj_post_df <- RunPCA(sobj_post_df, npcs=50)\nsobj_post_df <- RunUMAP(sobj_post_df, dims = 1:50)\nsobj_post_df <- FindNeighbors(sobj_post_df)\nsobj_post_df <- FindClusters(sobj_post_df)\nsobj_post_df <- RunTSNE(sobj_post_df)\nsobj_post_df\n#20635 features across 34694 samples within 1 assay \n#02_SI_sobj_post_df.Robj---------\nsave(sobj_post_df, file=\"./output/processed/02_SI_sobj_post_df.Robj\")\n```\n:::\n\n\n\n\n## Post filtering #2 QC metrics\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nload(paste0(proj_dir, \"/output/processed/02_SI_sobj_post_df.Robj\"))\np1 <- VlnPlot(sobj_post_df, \n              features = c(\"nFeature_RNA\"), \n              ncol = 1, assay = \"RNA\", \n              group.by = \"orig.ident\", \n              cols = sample_colors, \n              stack = FALSE) \np2 <- VlnPlot(sobj_post_df, \n              features = c(\"nCount_RNA\"), \n              ncol = 1, \n              assay = \"RNA\", \n              group.by = \"orig.ident\",\n              cols = sample_colors, \n              stack = FALSE)  \np3 <- VlnPlot(sobj_post_df, \n              features = c(\"percent.mt\"),\n             ncol = 1, \n              assay = \"RNA\", \n              group.by = \"orig.ident\", \n              cols = sample_colors, \n              stack = FALSE) \n\np4 <- VlnPlot(sobj_post_df, \n              features = c(\"log10genes_per_UMI\"), \n              ncol = 1, \n              assay = \"RNA\", \n              group.by = \"orig.ident\", \n              cols = sample_colors, \n              stack = FALSE) \n\n# Visualize the distribution of genes detected per cell via histogram\n  # single peak represents cells encapsulated\n  # shoulder/bimodal distribution: 1.cells that failed, 2. biologically different types (quiescent cells, less complex cells,size)\np5 <- sobj_post_df@meta.data  %>% \n  ggplot(aes(color=orig.ident, x=nFeature_RNA, fill= orig.ident)) + \n  geom_density(alpha = 0.2) + \n  theme_classic() +\n  scale_x_log10() + \n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) + geom_vline(xintercept = 4000) +\n  geom_vline(xintercept = 300) & NoLegend()\n\n\n# Visualize the number UMIs/transcripts per cell\n  # UMI count should be above 500 low-end, expected\n  # between 500-1000 counts, usable should have been sequenced more deeply\np6 <- sobj_post_df@meta.data %>% \n  ggplot(aes(color=orig.ident, x=nCount_RNA, fill= orig.ident)) + \n  geom_density(alpha = 0.2) + \n  scale_x_log10() + \n  theme_classic() +\n  ylab(\"Cell density\") +\n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) + geom_vline(xintercept = 500) + \n  geom_vline(xintercept = 20000) + \n  NoLegend()\n\n# Visualize the distribution of mitochondrial gene expression detected per cell\n  # indication if there's large amount of mito-contamination f. dead/dying cells, above 0.2 mito ratio mark poor quality, unless expected differently \n\np7 <- sobj_post_df@meta.data %>%\n  ggplot(aes(color=orig.ident, x=percent.mt, fill=orig.ident)) + \n  geom_density(alpha = 0.2) + \n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) +\n  scale_x_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 5) & NoLegend()\n\n\n# Visualize the overall complexity of the gene expression by visualizing the genes detected per UMI\n  # novelty score: ratio Genes/UMI\n  # highUMI & low Genes = only little genes, sequences over again == low complexity/novelty; associated to cell type? or  artifact?\n  # above 0.8\np8 <- sobj_post_df@meta.data %>%\n  ggplot(aes(x=log10genes_per_UMI, color = orig.ident, fill=orig.ident)) +\n  geom_density(alpha = 0.2) +\n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) +\n  theme_classic() +\n  geom_vline(xintercept = 0.8) & NoLegend()\n\n# FeatureScatter plot for nCount_RNA vs nFeature_RNA\n# Generate the FeatureScatter plot as a ggplot object\np9 <- FeatureScatter(\n    object = sobj_post_df, \n    group.by = \"orig.ident\",\n    split.by = NULL,\n    feature1 = \"nCount_RNA\", \n    cols = sample_colors,\n    feature2 = \"nFeature_RNA\", \n    shuffle = TRUE, \n    plot.cor = FALSE\n)\n\np9 <- p9 + \n    geom_vline(xintercept = 500, color = \"blue\", linetype = \"dashed\") + \n    geom_vline(xintercept = 20000, color = \"red\", linetype = \"dashed\") + \n    geom_hline(yintercept = 300, color = \"blue\", linetype = \"dashed\") + \n    geom_hline(yintercept = 4000, color = \"red\", linetype = \"dashed\") + \n    annotate(\"text\", x = 500, y = 3500, \n             label = \"500\", color = \"blue\", vjust = -0.5, hjust = -0.1, angle = 90) +\n  annotate(\"text\", x = 20000, y = 2500, \n             label = \"20000\", color = \"red\", vjust = -0.5, hjust = -0.1, angle = 90) +\n    annotate(\"text\", x = 19000, y = 300, \n             label = \"300\", color = \"blue\", vjust = -0.5, hjust = -0.1) +\n  annotate(\"text\", x = 500, y = 3700, \n             label = \"4000\", color = \"red\", vjust = -0.5, hjust = -0.1) \n\n# FeatureScatter plot for nCount_RNA vs percent.mt\np10 <- FeatureScatter(\n    object = sobj_post_df, \n    group.by = \"orig.ident\",\n    split.by = NULL,\n    feature1 = \"nFeature_RNA\", \n    cols = sample_colors,\n    feature2 = \"percent.mt\", \n    shuffle = TRUE, \n    plot.cor = FALSE\n)  \n\np10 <- p10 + \n    geom_vline(xintercept = 300, color = \"blue\", linetype = \"dashed\") + \n    geom_vline(xintercept = 4000, color = \"red\", linetype = \"dashed\") + \n    geom_hline(yintercept = 5, color = \"red\", linetype = \"dashed\") + \n    annotate(\"text\", x = 300, y = 4, \n             label = \"300\", color = \"blue\", vjust = -0.5, hjust = -0.1, angle = 90) +\n    annotate(\"text\", x = 4000, y = 4.9, \n             label = \"5%\", color = \"red\", vjust = -0.5, hjust = -0.1) +\n    annotate(\"text\", x = 4000, y = 4, \n             label = \"4000\", color = \"red\", vjust = -0.5, hjust = -0.1, angle = 90)\n\np <- p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8 + plot_layout(\n    ncol = 4, guides = \"collect\") + plot_annotation(\n        title = \"After filtering\", \n        tag_levels = \"A\")\np\n```\n\n::: {.cell-output-display}\n![](02_quality_control_files/figure-html/02_SI_12_post_df_filtering_qc_matrics-1.png){fig-align='center' width=90%}\n:::\n\n```{.r .cell-code}\np <- p9 + p10 + plot_layout(\n    ncol = 2, guides = \"collect\") + plot_annotation(\n        title = \"After filtering\", \n        tag_levels = \"A\")\np\n```\n\n::: {.cell-output-display}\n![](02_quality_control_files/figure-html/02_SI_12_post_df_filtering_qc_matrics-2.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n\n# Dimensionality reduction {.tabset}\n\nDimensionality reduction plots coloured by technical factors can help identify if there are any factors driving the clusters in the dataset.\n\n::: panel-tabset\n### PCA\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Calculate the variance explained by each PC\npca_stdev <- Stdev(sobj_post_df, reduction = \"pca\")\npca_variance <- pca_stdev^2\npca_variance_explained <- round(100 * pca_variance / sum(pca_variance), 2)\n\n# Extract the percentages for PC1 and PC2\npc1_variance <- pca_variance_explained[1]\npc2_variance <- pca_variance_explained[2]\n\n# FeaturePlots with variance explained in the title\np1 <- FeaturePlot(sobj_post_df, features = \"nCount_RNA\", reduction = \"pca\") +\n  ggtitle(paste0(\"nCount_RNA (PC1: \", pc1_variance, \"%, PC2: \", pc2_variance, \"%)\"))\n\n\np1 <- FeaturePlot(sobj_post_df, features = \"nCount_RNA\", reduction = \"pca\")\np2 <- FeaturePlot(sobj_post_df, features = \"nFeature_RNA\", reduction = \"pca\")\np3 <- FeaturePlot(sobj_post_df, features = \"percent.mt\", reduction = \"pca\")\np4 <- FeaturePlot(sobj_post_df, features = \"log10genes_per_UMI\", reduction = \"pca\")\np5 <- DimPlot(sobj_post_df, group.by = \"SelMethod\", reduction = \"pca\")\np6 <- DimPlot(sobj_post_df, group.by = \"sample\", reduction = \"pca\")\n\n\np <- p1 + p2 + p3 + p4 + p5 + p6 + plot_layout(\n    ncol = 2) + plot_annotation(\n        title = (paste0(\"After filtering - PCA (PC1:\", pc1_variance, \"%, PC2:\", pc2_variance, \"%)\")), \n        tag_levels = \"A\")\np\n```\n\n::: {.cell-output-display}\n![](02_quality_control_files/figure-html/02_SI_13_post_filtering_pca-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n\n### UMAP\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\np1 <- FeaturePlot(sobj_post_df, features = \"nCount_RNA\", reduction = \"umap\")\np2 <- FeaturePlot(sobj_post_df, features = \"nFeature_RNA\", reduction = \"umap\")\np3 <- FeaturePlot(sobj_post_df, features = \"percent.mt\", reduction = \"umap\")\np4 <- FeaturePlot(sobj_post_df, features = \"log10genes_per_UMI\", reduction = \"umap\")\np5 <- DimPlot(sobj_post_df, group.by = \"SelMethod\", reduction = \"umap\")\np6 <- DimPlot(sobj_post_df, group.by = \"sample\", reduction = \"umap\")\n\np <- p1 + p2 + p3 + p4 + p5 + p6 + plot_layout(\n    ncol = 2) + plot_annotation(\n        title = \"After filtering - UMAP\", \n        tag_levels = \"A\")\np\n```\n\n::: {.cell-output-display}\n![](02_quality_control_files/figure-html/02_SI_14_post_filtering_umap-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n\n### t-SNE\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\np1 <- FeaturePlot(sobj_post_df, features = \"nCount_RNA\", reduction = \"tsne\")\np2 <- FeaturePlot(sobj_post_df, features = \"nFeature_RNA\", reduction = \"tsne\")\np3 <- FeaturePlot(sobj_post_df, features = \"percent.mt\", reduction = \"tsne\")\np4 <- FeaturePlot(sobj_post_df, features = \"log10genes_per_UMI\", reduction = \"tsne\")\np5 <- DimPlot(sobj_post_df, group.by = \"SelMethod\", reduction = \"tsne\")\np6 <- DimPlot(sobj_post_df, group.by = \"sample\", reduction = \"tsne\")\n\np <- p1 + p2 + p3 + p4 + p5 + p6 + plot_layout(\n    ncol = 2) + plot_annotation(\n        title = \"After filtering - tsne\", \n        tag_levels = \"A\")\np\n```\n\n::: {.cell-output-display}\n![](02_quality_control_files/figure-html/02_SI_15_post_filtering_tsne-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n:::\n\nSeems like there are no extreme clusters formed due to technical factors. Next, we will look at validating our filters by various means.\n\n# Validation\n\n## Gene expression\n\nThe relationship between the number of cells that express a gene and the overall expression level can be interesting. We expect to see that higher expressed genes are expressed in more cells but there may be some that stand out from this. Since we already filtered out genes that were expressed in less than 5 cells, we dont expect outliers in that direction.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Get raw or normalized expression data\nexpr_data <- GetAssayData(sobj_post_df, slot = \"data\")  # Log-normalized counts\n\n# Calculate percentage of cells expressing each gene\npct_cells_expressing <- rowSums(expr_data > 0) / ncol(expr_data) * 100  # Percentage\n\n# Calculate mean expression for each gene\nmean_expression <- rowMeans(expr_data)\n\n# Combine into a data frame\ngene_stats <- data.frame(\n  Gene = rownames(expr_data),\n  PctCellsExpressing = pct_cells_expressing,\n  MeanExpression = mean_expression\n)\n\n# Count genes expressed in at least 50% and 25% of cells\ngenes_50 <- sum(gene_stats$PctCellsExpressing >= 50)\ngenes_25 <- sum(gene_stats$PctCellsExpressing >= 25)\n\n# Create the plot with axes switched\np_gene_exp <- ggplot(gene_stats, aes(x = PctCellsExpressing, y = MeanExpression)) +\n  geom_point(alpha = 0.6) +  # Scatter points\n  geom_smooth(color = \"red\", se = TRUE) +  # Trend line\n  geom_vline(xintercept = 50, linetype = \"dashed\", color = \"blue\") +  \n  annotate(\"text\", x = 47, y = 3,\n           label = paste0(genes_50, \" genes ≥ 50%\"), hjust = 0, angle = 90) +\n  geom_vline(xintercept = 25, linetype = \"dashed\", color = \"blue\") +  \n  annotate(\"text\", x = 22, y = 3, \n           label = paste0(genes_25, \" genes ≥ 25%\"), hjust = 0, angle = 90) +\n  scale_x_continuous(name = \"Percentage of cells expressing\", limits = c(0, 100)) +\n  scale_y_continuous(name = \"Mean expression\") +\n  theme_minimal()\np_gene_exp\n```\n\n::: {.cell-output-display}\n![](02_quality_control_files/figure-html/02_SI_16_gene_exp_freq-1.png){fig-align='center' width=90%}\n:::\n\n```{.r .cell-code}\n#The outlier gene expressed in 100% cells and mean exp 5 is Gm42418\n```\n:::\n\n\n\n\n## Gene variance\n\nThis plot shows the percentage of variance in the dataset that is explained by various technical factors. I am using the variancePartition package which is designed to estimate the contribution of different factors to the variance of each gene's expression across the dataset to quantify how much each factor (e.g., sample, technical effects) contributes to the total variation in gene expression.\n\nFor each gene in the dataset, it fits a linear mixed model (LMM) where the expression of the gene is modeled as a function of multiple explanatory variables (factors). The output is the percentage of variance in the gene's expression that can be attributed to each factor, in other words, the proportion of variance explained by each factor per gene.\n\nThis is another way of validating our gene filtering. If the variance in a lot of genes is explained by technical factors, then we have to reconsider our filters.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nload(paste0(proj_dir, \"/output/processed/02_SI_variancePartition.Robj\"))\n# Figure 1a\n# Bar plot of variance fractions for the first 10 genes\n# plotPercentBars(vp[1:10, ])\n\n# Variance explained by different technical factors\nplotVarPart(vp)\n\n# # Calculate variance explained by sample (categorical)\n# form <- ~ (1 | sample) + (1 | SelMethod) \n# varPart_cat <- fitExtractVarPartModel(expr_data, form, meta_data)\n# \n# # sort variables (i.e. columns) by median fraction\n# #       of variance explained\n# vp <- sortCols(varPart)\n# \n# # Figure 1a\n# # Bar plot of variance fractions for the first 10 genes\n# # plotPercentBars(vp[1:10, ])\n# \n# plotVarPart(vp)\n```\n:::\n\n\n\n\n![](../output/plots/02_quality_control/02_SI_17_variance-1.png)\n\nSince most of the variance in gene expression in the dataset is explained by residuals, this means that we did not introduce any bias.\n\n## PCA outliers\n\nAnother approach to validate our filters is to perform a PCA using technical factors instead of gene expression and then use outlier detection to identify low-quality cells.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Define technical factors\ntechnical_factors <- c(\"nCount_RNA\", \"nFeature_RNA\")\n\n# Subset metadata for PCA\nmeta_data_pca <- sobj_post_df@meta.data[, technical_factors]\n\n# Perform PCA using prcomp\npca_result <- prcomp(meta_data_pca, scale. = TRUE)\nsummary(pca_result)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nImportance of components:\n                         PC1    PC2\nStandard deviation     1.387 0.2757\nProportion of Variance 0.962 0.0380\nCumulative Proportion  0.962 1.0000\n```\n\n\n:::\n\n```{.r .cell-code}\n# Add PCA embeddings to the metadata\npca_embeddings <- as.data.frame(pca_result$x)\ncolnames(pca_embeddings) <- paste0(\"PC_\", 1:ncol(pca_embeddings))\nsobj_post_df@meta.data <- cbind(sobj_post_df@meta.data, pca_embeddings)\n\n# Calculate Z-scores for the first principal component\nsobj_post_df@meta.data$outlier_nCountRNA <- abs(scale(sobj_post_df@meta.data$PC_1)) > 4  # Threshold: Z > 3\n\n# Calculate Z-scores for the second principal component\nsobj_post_df@meta.data$outlier_nFeatureRNA <- abs(scale(sobj_post_df@meta.data$PC_2)) > 4  # Threshold: Z > 4\n\n# Create a new column indicating whether the sample is an outlier in either condition\nsobj_post_df@meta.data$outlier <- sobj_post_df@meta.data$outlier_nCountRNA | sobj_post_df@meta.data$outlier_nFeatureRNA\n\n# Scatter plot of PCA results\nggplot(sobj_post_df@meta.data, aes(x = PC_1, y = PC_2, color = outlier)) +\n  geom_point(alpha = 0.6) +\n  theme_minimal() +\n  scale_color_manual(values = c(\"FALSE\" = \"grey\", \"TRUE\" = \"red\")) +\n  labs(x = \"PC 1\", y = \"PC 2\", color = \"Outlier\")\n```\n\n::: {.cell-output-display}\n![](02_quality_control_files/figure-html/02_SI_18_pca_outliers_counts_features-1.png){fig-align='center' width=90%}\n:::\n\n```{.r .cell-code}\ntable(sobj_post_df@meta.data$outlier)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nFALSE  TRUE \n34568   112 \n```\n\n\n:::\n:::\n\n\n\n\nSince we don't see any egregious outliers, our filtering did not introduce any bias.\n\n## Kept vs Lost\n\nOne more thing we can look at is the expression level of genes between kept and removed cells. If we see known genes that are highly expressed in the removed cells that can indicate that we have removed an interesting population of cells from the dataset. The red line shows equal expression and the blue line is a linear fit.\n\n1.  X-Axis (LostCapped): Log average gene expression in removed cells.\n\n2.  Y-Axis (KeptCapped): Log average gene expression in kept cells.\n\n3.  Color (LostProp - KeptProp): Difference in proportion of cells expressing each gene between removed and kept populations. Positive values indicate a gene is more frequently expressed in the removed cells and vice versa. **Since most genes are negative, it means they are more prevalent in kept cells!**\n\n4.  Red Line: LostCapped = KeptCapped, indicating genes expressed equally in both removed and kept cells. Genes significantly above red line are more expressed in the kept cells and vice versa. **Majority of points cluster around the red line, especially for highly expressed genes. This is what we expect. There are some genes that have low average expression in removed cells (bottom right section under the red line) - these genes are typically indicative of poor quality cells (stressed, damaged, or empty droplets).**\n\n5.  Blue Line: Linear fit showing overall trend between gene expression in removed vs. kept. **The relationship is linear, so this is good - our filtering did not introduce any outliers!**\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nload(paste0(proj_dir, \"/output/processed/02_SI_sobj_scale.Robj\"))\n\n# Determine which cells are kept\npass_qc <- colnames(sobj) %in% colnames(sobj_post_df)\n\n# Add the pass_qc information to metadata\nsobj$pass_qc <- pass_qc\n\nsave(sobj, file=\"/home/nsingh/sterile_inflammation/output/processed/02_SI_sobj_pass_qc.Robj\")\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nload(paste0(proj_dir, \"/output/processed/02_SI_sobj_pass_qc.Robj\"))\n\nlibrary(tibble)\nlibrary(dplyr)\n\n# Determine which cells are kept\npass_qc <- colnames(sobj) %in% colnames(sobj_post_df)\n\n# Separate counts for kept and lost cells\nlost_counts <- as.matrix(sobj@assays[[\"RNA\"]]@layers[[\"counts\"]][, !pass_qc])\nkept_counts <- as.matrix(sobj@assays[[\"RNA\"]]@layers[[\"counts\"]][, pass_qc])\n\n# Check dimensions of lost and kept counts\ncat(\"Lost counts dimensions: \", dim(lost_counts), \"\\n\")\ncat(\"Kept counts dimensions: \", dim(kept_counts), \"\\n\")\n\n# Calculate average expression and detection proportion\nkept_lost <- tibble(\n    Gene     = rownames(sobj),\n    Lost     = rowMeans(lost_counts),\n    LostProp = rowSums(lost_counts > 0) / ncol(lost_counts),\n    Kept     = rowMeans(kept_counts),\n    KeptProp = rowSums(kept_counts > 0) / ncol(kept_counts)\n) %>%\n    # Calculate log fold change using a pseudo count for stability\n    mutate(LogFC = log2((Kept + 1) / (Lost + 1))) %>%\n    # Add capped values for stability in log-scale plots\n    mutate(\n        LostCapped = pmax(Lost, min(Lost[Lost > 0]) * 0.5),\n        KeptCapped = pmax(Kept, min(Kept[Kept > 0]) * 0.5)\n    )\n\nlibrary(viridis)\n\n# Plot\nggplot(kept_lost,\n       aes(x = LostCapped, y = KeptCapped, colour = LostProp - KeptProp)) +\n    geom_point(size = 1, alpha = 0.2) +\n    geom_abline(intercept = 0, slope = 1, colour = \"red\") +  # Red line for equality\n    geom_smooth(method = \"lm\", colour = \"blue\") +            # Blue line for linear fit\n    scale_x_log10() +\n    scale_y_log10() +\n    scale_colour_viridis_c() +\n    xlab(\"Average count (removed)\") +\n    ylab(\"Average count (kept)\") +\n    theme_minimal()\n\nkept_lost %>%\n    select(Gene, LogFC, Lost, LostProp, Kept, KeptProp) %>%\n    arrange(-LogFC) %>%\n    as.data.frame() %>%\n    head(100)\n```\n:::\n\n\n\n\n![](../output/plots/02_quality_control/02_SI_19_genes_kept_lost_exp_freq-1.png)\n\n# Main figures\n\n## Thresholds\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nload(paste0(proj_dir, \"/output/processed/02_SI_sobj_scale.Robj\"))\n\n# Thresholds\nfeature_lower <- 300\nfeature_upper <- 4000\ncount_lower <- 500\ncount_upper <- 20000\nmt_thresh <- 5\nlog10genes_thresh <- 0.8\n\n# Filtering results from the steps provided\nfilter_steps <- data.frame(\n  Step = c(\n    \"Initial Cells\", \n    \"nFeature_RNA > 300\", \n    \"nCount_RNA > 500\",\n    \"log10genes_per_UMI > 0.80\", \n    \"percent.mt < 5\",\n    \"Doublets Removed\",\n    \"nFeature_RNA < 4000\",\n    \"nCount_RNA < 20000\"\n  ),\n  Remaining_Cells = c(46155, 39911, 39249, 39231, 36838, 34815, 34698, 34680),\n  Removed_Cells = c(NA, -6244, -662, -18, -2393, -2023, -117, -18)\n)\n\n# Add metadata column for \"Kept\" based on all thresholds\nsobj@meta.data <- sobj@meta.data %>%\n  mutate(\n    Kept = nFeature_RNA > feature_lower & nFeature_RNA < feature_upper &\n           nCount_RNA > count_lower & nCount_RNA < count_upper &\n           percent.mt < mt_thresh & log10genes_per_UMI > log10genes_thresh\n  )\n\n# Prepare data for the Counts vs Features plot\nplot_data <- sobj@meta.data\n\n# Add filtering thresholds and removed cell info to the Counts vs Features plot\nexp_plot <- ggplot(plot_data, aes(x = nCount_RNA, y = nFeature_RNA, colour = Kept)) +\n  geom_point(alpha = 0.3) +\n  geom_vline(xintercept = count_lower, linetype = \"dashed\", colour = \"#8DC63F\") +\n  geom_vline(xintercept = count_upper, linetype = \"dashed\", colour = \"#8DC63F\") +\n  geom_hline(yintercept = feature_lower, linetype = \"dashed\", colour = \"#7A52C7\") +\n  geom_hline(yintercept = feature_upper, linetype = \"dashed\", colour = \"#7A52C7\") +\n  annotate(\"text\", x = count_lower, y = Inf, label = paste(\"Removed:\", -filter_steps$Removed_Cells[3]),\n           angle = 90, vjust = -0.5, hjust = 1, colour = \"#8DC63F\") +\n  annotate(\"text\", x = count_upper, y = Inf, label = paste(\"Removed:\", -filter_steps$Removed_Cells[8]),\n           angle = 90, vjust = -0.5, hjust = 1, colour = \"#8DC63F\") +\n  annotate(\"text\", x = Inf, y = feature_lower, label = paste(\"Removed:\", -filter_steps$Removed_Cells[2]),\n           vjust = -0.5, hjust = 1, colour = \"#7A52C7\") +\n  annotate(\"text\", x = Inf, y = feature_upper, label = paste(\"Removed:\", -filter_steps$Removed_Cells[7]),\n           vjust = -0.5, hjust = 1, colour = \"#7A52C7\") +\n  scale_colour_manual(values = c(\"#EC008C\", \"#00ADEF\"), labels = c(\"Removed\", \"Kept\")) +\n  labs(x = \"nCount_RNA\", y = \"nFeature_RNA\", colour = \"\", title = \"nCount_RNA (300-20,000) vs nFeature_RNA (500-4000)\") +\n  theme_minimal()\n\n# Add filtering thresholds and removed cell info to the Mitochondrial percentage plot\nmt_plot <- ggplot(plot_data, aes(x = percent.mt)) +\n  geom_histogram(bins = 100, fill = \"#7A52C7\", alpha = 0.7) +\n  geom_vline(xintercept = mt_thresh, linetype = \"dashed\", colour = \"#EC008C\") +\n  annotate(\"text\", x = 8, y = Inf, label = paste(\"Removed:\", -filter_steps$Removed_Cells[5]),\n           angle = 90, vjust = -0.5, hjust = 1, colour = \"#EC008C\") +\n  labs(x = \"Percentage mitochondrial\", y = \"Number of cells\", title = \"Mitochondrial content (<5%)\") +\n  theme_minimal()\n\n# Add filtering thresholds and removed cell info to the log10 Genes per UMI plot\numi_plot <- ggplot(plot_data, aes(x = log10genes_per_UMI)) +\n  geom_histogram(bins = 100, fill = \"#00ADEF\", alpha = 0.7) +\n  geom_vline(xintercept = log10genes_thresh, linetype = \"dashed\", colour = \"#EC008C\") +\n  annotate(\"text\", x = log10genes_thresh, y = Inf, label = paste(\"Removed:\", -filter_steps$Removed_Cells[4]),\n           angle = 90, vjust = -0.5, hjust = 1, colour = \"#EC008C\") +\n  labs(x = \"Log10 genes per UMI\", y = \"Number of cells\", title = \"Log10 genes per UMI (<0.8)\") +\n  theme_minimal()\n\n\n\n# Combine all plots into a single figure\nfig <- plot_grid(\n  exp_plot, mt_plot, umi_plot, \n  labels = \"AUTO\", ncol = 2\n)\nfig\n```\n:::\n\n\n\n\n![](../output/plots/02_quality_control/02_SI_main_1_thresholds-1.png)\n\n## Doublets\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Use cowplot to add the annotation near the legend\np_doublets <- ggdraw(p_doublets) + ggtitle(\"Doublets: removed 2023\")\np_doublets\n```\n:::\n\n\n\n\n## Validation\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nload(paste0(proj_dir, \"/output/processed/02_SI_sobj_pass_qc.Robj\"))\nlibrary(ggrepel)\n\n# Determine which cells are kept\npass_qc <- colnames(sobj) %in% colnames(sobj_post_df)\n\n# Separate counts for kept and lost cells\nlost_counts <- as.matrix(sobj@assays[[\"RNA\"]]@layers[[\"counts\"]][, !pass_qc])\nkept_counts <- as.matrix(sobj@assays[[\"RNA\"]]@layers[[\"counts\"]][, pass_qc])\n\n# Create a data frame for fold-change metrics\nkept_lost <- tibble(\n  Gene     = rownames(sobj),\n  Lost     = rowMeans(lost_counts),\n  LostProp = rowSums(lost_counts > 0) / ncol(lost_counts),\n  Kept     = rowMeans(kept_counts),\n  KeptProp = rowSums(kept_counts > 0) / ncol(kept_counts),\n  LogFC    = log2((rowMeans(kept_counts) + 1) / (rowMeans(lost_counts) + 1))\n)\n\n# Select the top 10 genes highly expressed in removed cells (lowest LogFC)\ntop_removed_genes <- kept_lost %>%\n  arrange(LogFC) %>%\n  slice_head(n = 10)\n\n# Select the top 10 genes highly expressed in kept cells (highest LogFC)\ntop_kept_genes <- kept_lost %>%\n  arrange(desc(LogFC)) %>%\n  slice_head(n = 10)\n\n# Add a column to indicate highlighted genes\nkept_lost <- kept_lost %>%\n  mutate(\n    Highlight = ifelse(Gene %in% c(top_removed_genes$Gene, top_kept_genes$Gene), Gene, NA)\n  )\n\n# Plot with highlighted genes\nfc_plot <- ggplot(kept_lost, aes(x = 0.5 * (Lost + Kept), y = LogFC, colour = LostProp - KeptProp)) +\n  geom_point(alpha = 0.3) +\n  geom_hline(yintercept = 0, colour = \"red\") +\n  scale_x_log10(labels = scales::number_format(accuracy = 0.0001)) +\n  scale_colour_viridis_c(name = \"Prop expressed (Removed) - Prop expressed (Kept)\") +\n  ggtitle(\"Fold-change between removed and kept cells\") +\n  xlab(\"0.5 * (Average expression (Kept) + Average expression (Removed))\") +\n  ylab(\"Predicted log2 fold-change (Removed / Kept)\") +\n  theme_minimal() +\n  theme(legend.position = \"bottom\") \n\n# Create a table for top fold-change genes\nfc_table <- kept_lost %>%\n  select(Gene, LogFC) %>%\n  arrange(-LogFC) %>%\n  head(15) %>%\n  tableGrob(rows = NULL, theme = ttheme_minimal())\n```\n:::\n\n\n\n\n![](../output/plots/02_quality_control/02_SI_main_2_validation.png)\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(DT)\nfc_table <- read.csv(paste0(proj_dir,\"/output/data/02_quality_control/02_SI_fold_change_genes.csv\"))\ndatatable(\n  fc_table,\n  options = list(),\n  rownames = TRUE\n)\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"datatables html-widget html-fill-item\" id=\"htmlwidget-e077fce1ca805971dae4\" style=\"width:100%;height:auto;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-e077fce1ca805971dae4\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"data\":[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\"],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15],[\"Wfdc17\",\"Fth1\",\"Ccl7\",\"Ccl4\",\"Retnla\",\"S100a9\",\"Mt1\",\"Ccl5\",\"Saa3\",\"Pf4\",\"Fcer1g\",\"Cd74\",\"S100a8\",\"Ccl12\",\"Cxcl10\"],[1.57870829419547,1.47469174234812,1.43832369439261,1.42483704104098,1.41754635633128,1.4168027744065,1.40510906863206,1.38783243546951,1.346057911411,1.34253924461949,1.34229887824956,1.32786150428571,1.32189961835241,1.30756635744846,1.28614409396045]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th> <\\/th>\\n      <th>X<\\/th>\\n      <th>Gene<\\/th>\\n      <th>LogFC<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"columnDefs\":[{\"className\":\"dt-right\",\"targets\":[1,3]},{\"orderable\":false,\"targets\":0},{\"name\":\" \",\"targets\":0},{\"name\":\"X\",\"targets\":1},{\"name\":\"Gene\",\"targets\":2},{\"name\":\"LogFC\",\"targets\":3}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false},\"selection\":{\"mode\":\"multiple\",\"selected\":null,\"target\":\"row\",\"selectable\":null}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\n\n::: panel-tabset\n\n#nCount_RNA\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nFeaturePlot(sobj_post_df, features = \"nCount_RNA\") +\n    scale_colour_viridis_c() +\n    ggtitle(\"nCount_RNA\") + NoAxes()\n```\n\n::: {.cell-output-display}\n![](02_quality_control_files/figure-html/02_SI_main_4_validation-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n\n#nFeature_RNA\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nFeaturePlot(sobj_post_df, features = \"nFeature_RNA\") +\n    scale_colour_viridis_c() +\n    ggtitle(\"nFeature_RNA\") + \n    NoAxes()\n```\n\n::: {.cell-output-display}\n![](02_quality_control_files/figure-html/02_SI_main_5_validation-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n\n#percent.mt\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nFeaturePlot(sobj_post_df, features = \"percent.mt\") +\n    scale_colour_viridis_c() +\n    ggtitle(\"% mito\") +\n    NoAxes()\n```\n\n::: {.cell-output-display}\n![](02_quality_control_files/figure-html/02_SI_main_6_validation-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n\n#Log 10 genes / log 10 UMI\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nFeaturePlot(sobj_post_df, features = \"log10genes_per_UMI\") +\n    scale_colour_viridis_c() +\n    ggtitle(\"Log10 genes per UMI\") +\n    NoAxes()\n```\n\n::: {.cell-output-display}\n![](02_quality_control_files/figure-html/02_SI_main_7_validation-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n\n:::\n\n# Summary\n\nAfter quality control we have a dataset with 34,694 cells and 20,635 genes.\n\n## Parameters\n\nThis table describes parameters used and set in this document.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Filtering results from the steps provided\nfilter_steps <- data.frame(\n  Step = c(\n    \"Initial Cells\", \n    \"nFeature_RNA > 300\", \n    \"nCount_RNA > 500\",\n    \"log10genes_per_UMI > 0.80\", \n    \"percent.mt < 5\",\n    \"Doublets Removed\",\n    \"nFeature_RNA < 4000\",\n    \"nCount_RNA < 20000\"\n  ),\n  Remaining_Cells = c(46155, 39911, 39249, 39231, 36838, 34815, 34698, 34680),\n  Removed_Cells = c(NA, -6244, -662, -18, -2393, -2023, -117, -18)\n)\n\n# Define the parameter descriptions and thresholds\nparameter_descriptions <- c(\n  \"Initial number of cells before filtering\",\n  \"Filter for cells with detected features above a minimum threshold\",\n  \"Filter for cells with total RNA counts above a minimum threshold\",\n  \"Filter for cells with sufficient gene complexity (log10 genes per UMI)\",\n  \"Filter for cells with mitochondrial percentage below a maximum threshold\",\n  \"Remove doublets identified using DoubletFinder\",\n  \"Filter for cells with detected features below a maximum threshold\",\n  \"Filter for cells with total RNA counts below a maximum threshold\"\n)\n\nthresholds <- c(\n  NA,  # Initial step has no threshold\n  \"> 300\", \n  \"> 500\", \n  \"> 0.80\", \n  \"< 5%\", \n  \"N/A\",  # Doublet removal isn't tied to a threshold\n  \"< 4000\", \n  \"< 20000\"\n)\n\n# Create the table\nfilter_table <- data.frame(\n  Parameter = c(\"Initial Cells\", \"nFeature_RNA\", \"nCount_RNA\", \"log10genes_per_UMI\", \"percent.mt\", \"Doublets\", \"nFeature_RNA\", \"nCount_RNA\"),\n  Description = parameter_descriptions,\n  Threshold = thresholds,\n  Cells_removed = abs(filter_steps$Removed_Cells),  # Absolute value for cells removed\n  Cells_remaining = filter_steps$Remaining_Cells\n)\n\nparams <- jsonlite::toJSON(filter_table, pretty = TRUE)\nknitr::kable(jsonlite::fromJSON(params))\n```\n\n::: {.cell-output-display}\n\n\n|Parameter          |Description                                                              | Cells_remaining|Threshold | Cells_removed|\n|:------------------|:------------------------------------------------------------------------|---------------:|:---------|-------------:|\n|Initial Cells      |Initial number of cells before filtering                                 |           46155|NA        |            NA|\n|nFeature_RNA       |Filter for cells with detected features above a minimum threshold        |           39911|> 300     |          6244|\n|nCount_RNA         |Filter for cells with total RNA counts above a minimum threshold         |           39249|> 500     |           662|\n|log10genes_per_UMI |Filter for cells with sufficient gene complexity (log10 genes per UMI)   |           39231|> 0.80    |            18|\n|percent.mt         |Filter for cells with mitochondrial percentage below a maximum threshold |           36838|< 5%      |          2393|\n|Doublets           |Remove doublets identified using DoubletFinder                           |           34815|N/A       |          2023|\n|nFeature_RNA       |Filter for cells with detected features below a maximum threshold        |           34698|< 4000    |           117|\n|nCount_RNA         |Filter for cells with total RNA counts below a maximum threshold         |           34680|< 20000   |            18|\n\n\n:::\n\n```{.r .cell-code}\n#write.csv(filter_table, \"./output/data/02_SI_qc_steps_summary.csv\", row.names = FALSE)\n```\n:::\n\n\n\n\n## Output files\n\nThis table describes the output files produced by this document. Right click and *Save Link As...* to download the results (to be implemented).\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsaved_files <- extract_saved_files(\"./analysis/02_quality_control.qmd\")\n#saved_files <- saved_files[-c(1, 2), ]\nprint(saved_files)\nwrite.csv(saved_files, file = paste0(proj_dir, \"/output/data/02_quality_control/02_SI_saved_files_summary.csv\"))\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsaved_files <- read.csv(file = paste0(proj_dir, \"/output/data/02_quality_control/02_SI_saved_files_summary.csv\"))\nparams <- jsonlite::toJSON(saved_files, pretty = TRUE)\nknitr::kable(jsonlite::fromJSON(params))\n```\n\n::: {.cell-output-display}\n\n\n|  X|File                                      |Directory                                                                       |Description                                                                              |\n|--:|:-----------------------------------------|:-------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------|\n|  1|selected                                  |file=here::here(output/processed/02_SI_selected.Robj)                           |SCE obj, add lib size, normalize                                                         |\n|  2|sobj                                      |file=/home/nsingh/sterile_inflammation/output/processed/02_SI_sobj.Robj         |initial SO, unfiltered                                                                   |\n|  3|sobj                                      |file=/home/nsingh/sterile_inflammation/output/processed/02_SI_sobj_scale.Robj   |initial SO; unfiltered, scaled                                                           |\n|  4|filtered_sobj                             |file=./output/processed/02_SI_sobj_qc.Robj                                      |SO post filtering #1                                                                     |\n|  5|sobj_out_list                             |file=./output/processed/02_SI_sobj_df_out_list.Robj                             |List of seurat objects split by sample after running doublet finder on each individually |\n|  6|bcmvn_list                                |file=./output/processed/02_SI_bcmvn_df_out_list.Robj                            |List of bcmvn split by sample after running doublet finder on each individually          |\n|  7|filtered_sobj, file = paste0(sobj_dir,tag |_sobj_df.Robj)                                                                  |SO post doublet finder all sample results combined                                       |\n|  8|sobj_post_df                              |file=./output/processed/02_SI_sobj_post_df.Robj                                 |SO post filtering #2                                                                     |\n|  9|vp                                        |file = ./output/processed/02_SI_variancePartition.Robj                          |variance partition on qc metrics                                                         |\n| 10|sobj                                      |file=/home/nsingh/sterile_inflammation/output/processed/02_SI_sobj_pass_qc.Robj |intial SO, add metadata whether cells passed qc                                          |\n\n\n:::\n:::\n\n\n\n\n# Session information\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndevtools::session_info()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.3 (2024-02-29)\n os       macOS Sonoma 14.6.1\n system   x86_64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/Vienna\n date     2025-01-21\n pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n ! package              * version    date (UTC) lib source\n P abind                  1.4-8      2024-09-12 [?] CRAN (R 4.3.3)\n   beeswarm               0.4.0      2021-06-01 [1] RSPM (R 4.3.0)\n   Biobase              * 2.62.0     2023-10-24 [1] Bioconductor\n   BiocGenerics         * 0.48.1     2023-11-01 [1] Bioconductor\n P BiocManager            1.30.25    2024-08-28 [?] CRAN (R 4.3.3)\n   BiocParallel           1.36.0     2023-10-24 [1] Bioconductor\n P bitops                 1.0-9      2024-10-03 [?] CRAN (R 4.3.3)\n   bslib                  0.8.0      2024-07-29 [1] RSPM (R 4.3.0)\n P cachem                 1.1.0      2024-05-16 [?] CRAN (R 4.3.3)\n   cli                    3.6.3      2024-06-21 [1] RSPM (R 4.3.0)\n P cluster                2.1.6      2023-12-01 [?] CRAN (R 4.3.3)\n P codetools              0.2-19     2023-02-01 [?] CRAN (R 4.3.3)\n P colorspace             2.1-1      2024-07-26 [?] CRAN (R 4.3.3)\n P cowplot              * 1.1.3      2024-01-22 [?] CRAN (R 4.3.2)\n P crayon                 1.5.3      2024-06-20 [?] CRAN (R 4.3.3)\n P crosstalk              1.2.1      2023-11-23 [?] CRAN (R 4.3.0)\n P data.table             1.16.4     2024-12-06 [?] RSPM\n   DelayedArray           0.28.0     2023-10-24 [1] Bioconductor\n P deldir                 2.0-4      2024-02-28 [?] CRAN (R 4.3.2)\n P devtools               2.4.5      2022-10-11 [?] CRAN (R 4.3.0)\n   digest                 0.6.37     2024-08-19 [1] RSPM (R 4.3.0)\n P dotCall64              1.2        2024-10-04 [?] CRAN (R 4.3.3)\n P dplyr                * 1.1.4      2023-11-17 [?] CRAN (R 4.3.0)\n P DT                   * 0.33       2024-04-04 [?] CRAN (R 4.3.2)\n P ellipsis               0.3.2      2021-04-29 [?] CRAN (R 4.3.0)\n   evaluate               1.0.1      2024-10-10 [1] RSPM (R 4.3.0)\n P farver                 2.1.2      2024-05-13 [?] CRAN (R 4.3.3)\n P fastDummies            1.7.4      2024-08-16 [?] RSPM\n P fastmap                1.2.0      2024-05-15 [?] CRAN (R 4.3.3)\n P fitdistrplus           1.2-1      2024-07-12 [?] CRAN (R 4.3.3)\n P forcats              * 1.0.0      2023-01-29 [?] RSPM\n   fs                     1.6.5      2024-10-30 [1] RSPM (R 4.3.0)\n P future                 1.34.0     2024-07-29 [?] CRAN (R 4.3.3)\n P future.apply           1.11.3     2024-10-27 [?] CRAN (R 4.3.3)\n P generics               0.1.3      2022-07-05 [?] CRAN (R 4.3.0)\n   GenomeInfoDb         * 1.38.8     2024-03-15 [1] Bioconductor 3.18 (R 4.3.3)\n   GenomeInfoDbData       1.2.11     2024-12-25 [1] Bioconductor\n   GenomicRanges        * 1.54.1     2023-10-29 [1] Bioconductor\n   ggbeeswarm             0.7.2      2023-04-29 [1] RSPM (R 4.3.0)\n P ggplot2              * 3.5.1      2024-04-23 [?] CRAN (R 4.3.2)\n   ggrastr                1.0.2      2023-06-01 [1] RSPM (R 4.3.3)\n P ggrepel                0.9.6      2024-09-07 [?] CRAN (R 4.3.3)\n P ggridges               0.5.6      2024-01-23 [?] CRAN (R 4.3.2)\n P globals                0.16.3     2024-03-08 [?] CRAN (R 4.3.2)\n   glue                   1.8.0      2024-09-30 [1] RSPM (R 4.3.0)\n P goftest                1.2-3      2021-10-07 [?] CRAN (R 4.3.0)\n P gridExtra            * 2.3        2017-09-09 [?] CRAN (R 4.3.0)\n P gtable                 0.3.6      2024-10-25 [?] CRAN (R 4.3.3)\n P here                 * 1.0.1      2020-12-13 [?] CRAN (R 4.3.0)\n P hms                    1.1.3      2023-03-21 [?] CRAN (R 4.3.0)\n P htmltools              0.5.8.1    2024-04-04 [?] CRAN (R 4.3.2)\n P htmlwidgets            1.6.4      2023-12-06 [?] CRAN (R 4.3.0)\n P httpuv                 1.6.15     2024-03-26 [?] CRAN (R 4.3.2)\n P httr                   1.4.7      2023-08-15 [?] CRAN (R 4.3.0)\n P ica                    1.0-3      2022-07-08 [?] CRAN (R 4.3.0)\n P igraph                 2.1.2      2024-12-07 [?] RSPM\n   IRanges              * 2.36.0     2023-10-24 [1] Bioconductor\n P irlba                  2.3.5.1    2022-10-03 [?] CRAN (R 4.3.0)\n P jquerylib              0.1.4      2021-04-26 [?] CRAN (R 4.3.0)\n   jsonlite               1.8.9      2024-09-20 [1] RSPM (R 4.3.0)\n P KernSmooth             2.23-24    2024-05-17 [?] CRAN (R 4.3.3)\n   knitr                  1.49       2024-11-08 [1] RSPM (R 4.3.0)\n P labeling               0.4.3      2023-08-29 [?] CRAN (R 4.3.0)\n P later                  1.4.1      2024-11-27 [?] RSPM\n P lattice                0.22-5     2023-10-24 [?] CRAN (R 4.3.3)\n P lazyeval               0.2.2      2019-03-15 [?] CRAN (R 4.3.0)\n P leiden                 0.4.3.1    2023-11-17 [?] CRAN (R 4.3.0)\n P lifecycle              1.0.4      2023-11-07 [?] CRAN (R 4.3.0)\n P listenv                0.9.1      2024-01-29 [?] CRAN (R 4.3.2)\n P lmtest                 0.9-40     2022-03-21 [?] CRAN (R 4.3.0)\n P lubridate            * 1.9.4      2024-12-08 [?] RSPM\n   magrittr               2.0.3      2022-03-30 [1] RSPM (R 4.3.0)\n P MASS                   7.3-60.0.1 2024-01-13 [?] CRAN (R 4.3.3)\n P Matrix                 1.6-5      2024-01-11 [?] CRAN (R 4.3.3)\n   MatrixGenerics       * 1.14.0     2023-10-24 [1] Bioconductor\n P matrixStats          * 1.4.1      2024-09-08 [?] CRAN (R 4.3.3)\n P memoise                2.0.1      2021-11-26 [?] CRAN (R 4.3.0)\n P mgcv                   1.9-1      2023-12-21 [?] CRAN (R 4.3.3)\n P mime                   0.12       2021-09-28 [?] CRAN (R 4.3.0)\n P miniUI                 0.1.1.1    2018-05-18 [?] CRAN (R 4.3.0)\n P munsell                0.5.1      2024-04-01 [?] CRAN (R 4.3.2)\n P nlme                   3.1-164    2023-11-27 [?] CRAN (R 4.3.3)\n P parallelly             1.41.0     2024-12-18 [?] RSPM\n P patchwork            * 1.3.0      2024-09-16 [?] CRAN (R 4.3.3)\n P pbapply                1.7-2      2023-06-27 [?] CRAN (R 4.3.0)\n P pillar                 1.10.0     2024-12-17 [?] RSPM\n P pkgbuild               1.4.5      2024-10-28 [?] CRAN (R 4.3.3)\n P pkgconfig              2.0.3      2019-09-22 [?] CRAN (R 4.3.0)\n P pkgload                1.4.0      2024-06-28 [?] RSPM\n P plotly                 4.10.4     2024-01-13 [?] CRAN (R 4.3.0)\n P plyr                   1.8.9      2023-10-02 [?] CRAN (R 4.3.0)\n P png                    0.1-8      2022-11-29 [?] CRAN (R 4.3.0)\n P polyclip               1.10-7     2024-07-23 [?] RSPM\n P profvis                0.4.0      2024-09-20 [?] CRAN (R 4.3.3)\n P progressr              0.15.1     2024-11-22 [?] RSPM\n P promises               1.3.2      2024-11-28 [?] RSPM\n P purrr                * 1.0.2      2023-08-10 [?] CRAN (R 4.3.0)\n P R6                     2.5.1      2021-08-19 [?] CRAN (R 4.3.0)\n P RANN                   2.6.2      2024-08-25 [?] RSPM\n P RColorBrewer           1.1-3      2022-04-03 [?] CRAN (R 4.3.0)\n P Rcpp                   1.0.13-1   2024-11-02 [?] CRAN (R 4.3.3)\n P RcppAnnoy              0.0.22     2024-01-23 [?] CRAN (R 4.3.2)\n P RcppHNSW               0.6.0      2024-02-04 [?] CRAN (R 4.3.2)\n   RCurl                  1.98-1.16  2024-07-11 [1] RSPM (R 4.3.0)\n P readr                * 2.1.5      2024-01-10 [?] RSPM\n P remotes                2.5.0      2024-03-17 [?] RSPM\n   renv                   1.0.11     2024-10-12 [1] RSPM (R 4.3.0)\n P reshape2               1.4.4      2020-04-09 [?] CRAN (R 4.3.0)\n P reticulate             1.40.0     2024-11-15 [?] CRAN (R 4.3.3)\n   rlang                  1.1.4      2024-06-04 [1] RSPM (R 4.3.0)\n   rmarkdown              2.29       2024-11-04 [1] RSPM (R 4.3.0)\n P ROCR                   1.0-11     2020-05-02 [?] CRAN (R 4.3.0)\n P rprojroot              2.0.4      2023-11-05 [?] CRAN (R 4.3.0)\n P RSpectra               0.16-2     2024-07-18 [?] RSPM\n P rstudioapi             0.17.1     2024-10-22 [?] CRAN (R 4.3.3)\n P Rtsne                  0.17       2023-12-07 [?] CRAN (R 4.3.0)\n   S4Arrays               1.2.1      2024-03-06 [1] Bioconductor 3.18 (R 4.3.3)\n   S4Vectors            * 0.40.2     2023-11-23 [1] Bioconductor\n P sass                   0.4.9      2024-03-15 [?] CRAN (R 4.3.2)\n P scales                 1.3.0      2023-11-28 [?] CRAN (R 4.3.0)\n P scattermore            1.2        2023-06-12 [?] CRAN (R 4.3.0)\n P sctransform            0.4.1      2023-10-19 [?] CRAN (R 4.3.0)\n P sessioninfo            1.2.2      2021-12-06 [?] CRAN (R 4.3.0)\n P Seurat               * 5.1.0      2024-05-10 [?] CRAN (R 4.3.3)\n P SeuratObject         * 5.0.2      2024-05-08 [?] CRAN (R 4.3.2)\n P shiny                  1.10.0     2024-12-14 [?] RSPM\n   SingleCellExperiment * 1.24.0     2023-10-24 [1] Bioconductor\n P sp                   * 2.1-4      2024-04-30 [?] CRAN (R 4.3.3)\n P spam                   2.11-0     2024-10-03 [?] CRAN (R 4.3.3)\n   SparseArray            1.2.4      2024-02-11 [1] Bioconductor 3.18 (R 4.3.2)\n P spatstat.data          3.1-4      2024-11-15 [?] CRAN (R 4.3.3)\n P spatstat.explore       3.3-3      2024-10-22 [?] CRAN (R 4.3.3)\n P spatstat.geom          3.3-4      2024-11-18 [?] RSPM\n P spatstat.random        3.3-2      2024-09-18 [?] CRAN (R 4.3.3)\n P spatstat.sparse        3.1-0      2024-06-21 [?] RSPM\n P spatstat.univar        3.1-1      2024-11-05 [?] CRAN (R 4.3.3)\n P spatstat.utils         3.1-1      2024-11-03 [?] CRAN (R 4.3.3)\n P stringi                1.8.4      2024-05-06 [?] CRAN (R 4.3.2)\n   stringr              * 1.5.1      2023-11-14 [1] RSPM (R 4.3.0)\n   SummarizedExperiment * 1.32.0     2023-10-24 [1] Bioconductor\n P survival               3.5-8      2024-02-14 [?] CRAN (R 4.3.3)\n P tensor                 1.5        2012-05-05 [?] CRAN (R 4.3.0)\n P tibble               * 3.2.1      2023-03-20 [?] CRAN (R 4.3.0)\n P tidyr                * 1.3.1      2024-01-24 [?] CRAN (R 4.3.2)\n P tidyselect             1.2.1      2024-03-11 [?] CRAN (R 4.3.2)\n P tidyverse            * 2.0.0      2023-02-22 [?] CRAN (R 4.3.0)\n P timechange             0.3.0      2024-01-18 [?] CRAN (R 4.3.0)\n P tzdb                   0.4.0      2023-05-12 [?] CRAN (R 4.3.0)\n P urlchecker             1.0.1      2021-11-30 [?] CRAN (R 4.3.0)\n P usethis                3.1.0      2024-11-26 [?] CRAN (R 4.3.3)\n P uwot                   0.2.2      2024-04-21 [?] RSPM\n P vctrs                  0.6.5      2023-12-01 [?] CRAN (R 4.3.0)\n   vipor                  0.4.7      2023-12-18 [1] RSPM (R 4.3.0)\n P viridisLite            0.4.2      2023-05-02 [?] CRAN (R 4.3.0)\n P withr                  3.0.2      2024-10-28 [?] CRAN (R 4.3.3)\n   xfun                   0.49       2024-10-31 [1] RSPM (R 4.3.0)\n P xtable                 1.8-4      2019-04-21 [?] CRAN (R 4.3.0)\n   XVector                0.42.0     2023-10-24 [1] Bioconductor\n   yaml                   2.3.10     2024-07-26 [1] RSPM (R 4.3.0)\n   zlibbioc               1.48.2     2024-03-13 [1] Bioconductor 3.18 (R 4.3.3)\n P zoo                    1.8-12     2023-04-13 [?] CRAN (R 4.3.0)\n\n [1] /Users/nami/Desktop/sterile_inflammation/renv/library/R-4.3/x86_64-apple-darwin20\n [2] /Users/nami/Library/Caches/org.R-project.R/R/renv/sandbox/R-4.3/x86_64-apple-darwin20/b06620f4\n\n P ── Loaded and on-disk path mismatch.\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n",
    "supporting": [
      "02_quality_control_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../site_libs/htmltools-fill-0.5.8.1/fill.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<link href=\"../site_libs/datatables-css-0.0.0/datatables-crosstalk.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/datatables-binding-0.33/datatables.js\"></script>\n<script src=\"../site_libs/jquery-3.6.0/jquery-3.6.0.min.js\"></script>\n<link href=\"../site_libs/dt-core-1.13.6/css/jquery.dataTables.min.css\" rel=\"stylesheet\" />\n<link href=\"../site_libs/dt-core-1.13.6/css/jquery.dataTables.extra.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/dt-core-1.13.6/js/jquery.dataTables.min.js\"></script>\n<link href=\"../site_libs/crosstalk-1.2.1/css/crosstalk.min.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/crosstalk-1.2.1/js/crosstalk.min.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}