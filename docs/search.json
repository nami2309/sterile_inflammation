[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "analysis/about.html",
    "href": "analysis/about.html",
    "title": "About",
    "section": "",
    "text": "Sterile inflammation\nThis repository displays the analysis code and results for the sterile inflammation project in collaboration with Dr. Shweta Tikoo at the Deaprtment of Dermatology at the MedUni Wien.\nThe project aims to define changes in transcriptional landscape of stromal cells and leukocytes post sterile inflammation. These cells coordinate the recruitment of diverse immune cell subsets from circulation to the inflammed tissue to restrict inflammation and promote tissue repair.\nThe samples consist of FACS sorted cells from murine cremaster tissue under homeostasis or post-TNFa treatment at two different time points. The cells were then sequenced after cDNA libraries preparation.\nThe analysis shown here focuses on the decisions that were made during analysis and demonstrates a range of tools that can be used for various tasks.\nTo see the results of the analysis please visit the analysis website. If you wish to reproduce the analysis follow the instructions on the Getting started page.\nThe code in this analysis is covered by the MIT license and the written content on this website is covered by a Creative Commons CC-BY license.\nThe publications mentioned and datasets used are covered by their respective licenses and usage agreements. Please refer to those sources for details."
  },
  {
    "objectID": "analysis/license.html",
    "href": "analysis/license.html",
    "title": "License",
    "section": "",
    "text": "What license are you using for your code? See choosealicense.com for help deciding. It’s a convention to save a file LICENSE in the root of your Git repo that contains the license text.\nWhat license are you using for the written content on your site? It is traditional to choose a Creative Commons license for this type of content.\nHow should others cite your work? It’s a convention to save a file CITATION in the root of your Git repo that contains the citation information."
  },
  {
    "objectID": "analysis/02_quality_control.html",
    "href": "analysis/02_quality_control.html",
    "title": "Quality control",
    "section": "",
    "text": "Code\n# Define sample names\nsample_names &lt;- c(\"PVM_0h\", \"PVEU_0h\", \"PVM_4h\", \"PVEU_4h\", \"PVM_7h\", \"PVEU_7h\")\n\nsample_colors &lt;- c(\n  \"PVM_0h\"  = \"#EE9A49\",  \n  \"PVM_4h\"  = \"#CD853F\", \n  \"PVM_7h\" = \"#8B5A2B\",  \n  \"PVEU_0h\"  = \"#7EC0EE\",\n  \"PVEU_4h\" = \"#6CA6CD\", \n  \"PVEU_7h\" = \"#4A708B\"\n)\n\nscript_number &lt;- \"02_\"\nproject &lt;- \"SI\"\ntag &lt;- paste0(script_number,project)\n\nproj_dir &lt;- \"/Users/nami/Desktop/sterile_inflammation\"\nbpparam &lt;- BiocParallel::MulticoreParam(workers = 6)\noptions(future.globals.maxSize = 30 * 1024^3)\nCode\n# scRNA-seq\nlibrary(\"SingleCellExperiment\")\n# library(\"scater\")\n# library(\"scran\")\nlibrary(Seurat)\n#library(singleCellTK)\n\n# RNA-seq\n#library(\"edgeR\")\n\n# Plotting\nlibrary(\"cowplot\")\nlibrary(\"gridExtra\")\nlibrary(patchwork)\n\n# Tidyverse\nlibrary(\"tidyverse\")\n\nlibrary(here)\n#library(\"variancePartition\")\nlibrary(tidyr)\nlibrary(dplyr)\nCode\nsource(paste0(proj_dir, \"/functions/universal.R\"))"
  },
  {
    "objectID": "analysis/02_quality_control.html#check-lib-size-vs-normalization",
    "href": "analysis/02_quality_control.html#check-lib-size-vs-normalization",
    "title": "Quality control",
    "section": "Check lib size vs normalization",
    "text": "Check lib size vs normalization\n\nSCESeurat\n\n\n\n\nCode\nload(paste0(proj_dir, \"/output/processed/02_SI_selected.Robj\"))\nhist(log10(sizeFactors(selected)), xlab=\"Log10[sizeFactors]\", col='grey80')\nlibrary_sizes &lt;- colSums(counts(selected))\nmean_logcounts &lt;- colMeans(assay(selected, \"logcounts\"))\nplot(log10(library_sizes), mean_logcounts, \n     xlab = \"Log10 library size\", ylab = \"Mean log-normalized counts\",\n     main = \"Normalized counts vs library size\")\nabline(h = median(mean_logcounts), col = \"red\", lty = 2)\nrm(selected)\n\n\n\n\n\n\n\n\nCode\nload(paste0(proj_dir, \"/output/processed/02_SI_sobj_scale.Robj\"))\n# Extract library sizes\nlibrary_sizes &lt;- colSums(sobj@assays$RNA$counts)\n\n# Extract normalized data means\nmean_logcounts &lt;- Matrix::colMeans(sobj@assays$RNA$data)\n\n# Plot size factors vs library sizes\nplot(log10(library_sizes), mean_logcounts,\n     xlab = \"Log10 library size\",\n     ylab = \"Mean log-normalized counts\",\n     main = \"Normalized counts vs library size\")\nabline(h = median(mean_logcounts), col = \"red\", lty = 2)"
  },
  {
    "objectID": "analysis/02_quality_control.html#expression-by-cell---mads",
    "href": "analysis/02_quality_control.html#expression-by-cell---mads",
    "title": "Quality control",
    "section": "Expression by cell - MADs",
    "text": "Expression by cell - MADs\nDistributions by cell. Blue line shows the median and red lines show median absolute deviations (MADs) from the median.\n\nTotal countsTotal featuresPercent mitochondrial\n\n\n\n\nCode\nload(paste0(proj_dir, \"/output/processed/02_SI_sobj_scale.Robj\"))\noutlierHistogramSeurat(sobj, feature=\"nCount_RNA\", mads = 1:6)\n\n\n\n\n\n\n\nCode\noutlierHistogramSeurat(sobj, feature=\"nFeature_RNA\", mads = 1:6)\n\n\n\n\n\n\n\nCode\noutlierHistogramSeurat(sobj, feature=\"percent.mt\", mads = 1:6)"
  },
  {
    "objectID": "analysis/02_quality_control.html#expression-by-cell---manual",
    "href": "analysis/02_quality_control.html#expression-by-cell---manual",
    "title": "Quality control",
    "section": "Expression by cell - manual",
    "text": "Expression by cell - manual\n\nnCount_RNAnFeature_RNAPercent mitochondrialLog10 genes per UMI\n\n\n\n\nCode\np1 &lt;- VlnPlot(sobj, \n              features = c(\"nCount_RNA\"), \n              ncol = 1, \n              assay = \"RNA\", \n              group.by = \"orig.ident\",\n              cols = sample_colors, \n              stack = FALSE) & geom_hline(yintercept =500, col=\"blue\") \n              annotate(\"text\", x=0.5, y=1000, label=\"      500\", size=2,color = \"blue\")\n\n# Visualize the number UMIs/transcripts per cell\n# UMI count should be above 500 low-end, expected\n# between 500-1000 counts, usable should have been sequenced more deeply\np2 &lt;- sobj@meta.data %&gt;% \n  ggplot(aes(color=orig.ident, x=nCount_RNA, fill= orig.ident)) + \n  geom_density(alpha = 0.2) + \n  scale_x_log10() + \n  theme_classic() +\n  ylab(\"Cell density\") +\n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) + \n  geom_vline(xintercept = 500)\n  NoLegend()\n\n# FeatureScatter plot for nCount_RNA vs nFeature_RNA\n# Generate the FeatureScatter plot as a ggplot object\np3 &lt;- FeatureScatter(\n    object = sobj, \n    group.by = \"orig.ident\",\n    split.by = NULL,\n    feature1 = \"nCount_RNA\", \n    cols = sample_colors,\n    feature2 = \"nFeature_RNA\", \n    shuffle = TRUE, \n    plot.cor = FALSE\n)\n\np3 &lt;- p3 + \n    geom_vline(xintercept = 500, color = \"blue\", linetype = \"dashed\") + \n    geom_hline(yintercept = 300, color = \"blue\", linetype = \"dashed\") + \n    annotate(\"text\", x = 500, y = 4000, \n             label = \"500\", color = \"blue\", vjust = -0.5, hjust = -0.1, angle = 90) +\n    annotate(\"text\", x = 30000, y = 300, \n             label = \"300\", color = \"blue\", vjust = -0.5, hjust = -0.1)\n\n# FeatureScatter plot for nCount_RNA vs percent.mt\np4 &lt;- FeatureScatter(\n    object = sobj, \n    group.by = \"orig.ident\",\n    split.by = NULL,\n    feature1 = \"nCount_RNA\", \n    cols = sample_colors,\n    feature2 = \"percent.mt\", \n    shuffle = TRUE, \n    plot.cor = FALSE\n)  \n\np4 &lt;- p4 + \n    geom_vline(xintercept = 500, color = \"blue\", linetype = \"dashed\") + \n    geom_hline(yintercept = 5, color = \"red\", linetype = \"dashed\") + \n    annotate(\"text\", x = 500, y = 75, \n             label = \"500\", color = \"blue\", vjust = -0.5, hjust = -0.1, angle = 90) +\n    annotate(\"text\", x = 30000, y = 5, \n             label = \"5%\", color = \"red\", vjust = -0.5, hjust = -0.1)\n\n# Visualize the correlation between genes detected and number of UMIs and determine whether strong presence of cells with low numbers of genes/UMIs\n# poor quality cells likely to have low genes & UMIs per cell\np5 &lt;- sobj@meta.data %&gt;% \n  ggplot(aes(x=nCount_RNA, y=nFeature_RNA, color=percent.mt)) + \n  geom_point() + \n  scale_colour_gradient(low = \"gray90\", high = \"black\") +\n  stat_smooth(method=lm) +\n  scale_x_log10() + \n  scale_y_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 500) +\n  geom_hline(yintercept = 250) +\n  facet_wrap(~orig.ident)\n\np &lt;- p1 + p2 + p3 + p4 + p5 + plot_layout(\n    ncol = 2, guides = \"collect\") + plot_annotation(\n        title = \"Before filtering\", \n        tag_levels = \"A\")\np\n\n\n\n\n\n\n\nCode\np1 &lt;- VlnPlot(sobj, \n              features = c(\"nFeature_RNA\"), \n              ncol = 1, assay = \"RNA\", \n              group.by = \"orig.ident\", \n              cols = sample_colors, \n              stack = FALSE) & geom_hline(yintercept =300, col=\"blue\") & #geom_hline(yintercept = 3500, col=\"red\") & \n              annotate(\"text\", x=0.5, y=400, label=\"    300\", size=2,color = \"blue\") #& \n              #annotate(\"text\", x=0.5, y=3600, label=\"    3500\", size=2,color = \"red\") \n# Visualize the distribution of genes detected per cell via histogram\n# single peak represents cells encapsulated\n# shoulder/bimodal distribution: 1.cells that failed, 2. biologically different types (quiescent cells, less complex cells,size)\np2 &lt;- sobj@meta.data %&gt;% \n  ggplot(aes(color=orig.ident, x=nFeature_RNA, fill= orig.ident)) + \n  geom_density(alpha = 0.2) + \n  theme_classic() +\n  scale_x_log10() + \n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) + #geom_vline(xintercept = 3500) +\n  geom_vline(xintercept = 300) & NoLegend()#cutoff at &gt;400 ?\n\np3 &lt;- FeatureScatter(object = sobj, \n                        group.by = \"orig.ident\",\n                        split.by = NULL,\n                        feature1 = \"nCount_RNA\", \n                        cols = sample_colors,\n                        feature2 = \"nFeature_RNA\", \n        shuffle = TRUE, plot.cor = FALSE)  & NoLegend()\np3 &lt;- p3 + \n    geom_vline(xintercept = 500, color = \"blue\", linetype = \"dashed\") + \n    geom_hline(yintercept = 300, color = \"blue\", linetype = \"dashed\") + \n    annotate(\"text\", x = 500, y = 4000, \n             label = \"500\", color = \"blue\", vjust = -0.5, hjust = -0.1, angle = 90) +\n    annotate(\"text\", x = 30000, y = 300, \n             label = \"300\", color = \"blue\", vjust = -0.5, hjust = -0.1)\n\np4 &lt;- FeatureScatter(object = sobj, \n                        group.by = \"orig.ident\",\n                        split.by = NULL,\n                        feature1 = \"nFeature_RNA\", \n                        cols = sample_colors,\n                        feature2 = \"percent.mt\", \n        shuffle = TRUE, plot.cor = FALSE)  & NoLegend()\np4 &lt;- p4 + \n    geom_vline(xintercept = 300, color = \"blue\", linetype = \"dashed\") + \n    geom_hline(yintercept = 5, color = \"red\", linetype = \"dashed\") + \n    annotate(\"text\", x = 300, y = 75, \n             label = \"300\", color = \"blue\", vjust = -0.5, hjust = -0.1, angle = 90) +\n    annotate(\"text\", x = 30000, y = 5, \n             label = \"5%\", color = \"red\", vjust = -0.5, hjust = -0.1)\n\n# Visualize the correlation between genes detected and number of UMIs and determine whether strong presence of cells with low numbers of genes/UMIs\n# poor quality cells likely to have low genes & UMIs per cell\np5 &lt;- sobj@meta.data %&gt;% \n  ggplot(aes(x=nCount_RNA, y=nFeature_RNA, color=percent.mt)) + \n  geom_point() + \n  scale_colour_gradient(low = \"gray90\", high = \"black\") +\n  stat_smooth(method=lm) +\n  scale_x_log10() + \n  scale_y_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 500) +\n  geom_hline(yintercept = 250) +\n  facet_wrap(~orig.ident)\n\np &lt;- p1 + p2 + p3 + p4 + p5 + plot_layout(\n    ncol = 2, guides = \"collect\") + plot_annotation(\n        title = \"Before filtering\", \n        tag_levels = \"A\")\np\n\n\n\n\n\n\n\nCode\n# Visualize the distribution of mitochondrial gene expression detected per cell\n# indication if there's large amount of mito-contamination f. dead/dying cells, above 0.2 mito ratio mark poor quality, unless expected differently \np1 &lt;- VlnPlot(sobj, \n              features = c(\"percent.mt\"), \n              ncol = 1, \n              assay = \"RNA\", \n              group.by = \"orig.ident\", \n              cols = sample_colors, \n              stack = FALSE) & geom_hline(yintercept = 10, col=\"red\")& \n              annotate(\"text\", x=0.5, y=13, label=\"     5%\", size=3,color = \"red\") \n\np2 &lt;-sobj@meta.data %&gt;%\n  ggplot(aes(color=orig.ident, x=percent.mt, fill=orig.ident)) + \n  geom_density(alpha = 0.2) + \n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) +\n  scale_x_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 5) & NoLegend()\n\n# FeatureScatter plot for nCount_RNA vs percent.mt\np3 &lt;- FeatureScatter(\n    object = sobj, \n    group.by = \"orig.ident\",\n    split.by = NULL,\n    feature1 = \"nCount_RNA\", \n    cols = sample_colors,\n    feature2 = \"percent.mt\", \n    shuffle = TRUE, \n    plot.cor = FALSE\n)  \n\np3 &lt;- p3 + \n    geom_vline(xintercept = 500, color = \"blue\", linetype = \"dashed\") + \n    geom_hline(yintercept = 5, color = \"red\", linetype = \"dashed\") + \n    annotate(\"text\", x = 500, y = 75, \n             label = \"500\", color = \"blue\", vjust = -0.5, hjust = -0.1, angle = 90) +\n    annotate(\"text\", x = 30000, y = 5, \n             label = \"5%\", color = \"red\", vjust = -0.5, hjust = -0.1)\n\np4 &lt;- FeatureScatter(object = sobj, \n                        group.by = \"orig.ident\",\n                        split.by = NULL,\n                        feature1 = \"nFeature_RNA\", \n                        cols = sample_colors,\n                        feature2 = \"percent.mt\", \n        shuffle = TRUE, plot.cor = FALSE)  & NoLegend()\np4 &lt;- p4 + \n    geom_vline(xintercept = 300, color = \"blue\", linetype = \"dashed\") + \n    geom_hline(yintercept = 5, color = \"red\", linetype = \"dashed\") + \n    annotate(\"text\", x = 300, y = 75, \n             label = \"300\", color = \"blue\", vjust = -0.5, hjust = -0.1, angle = 90) +\n    annotate(\"text\", x = 30000, y = 5, \n             label = \"5%\", color = \"red\", vjust = -0.5, hjust = -0.1)\n\np &lt;- p1 + p2 + p3 + p4 + plot_layout(\n    ncol = 2, guides = \"collect\") + plot_annotation(\n        title = \"Before filtering\", \n        tag_levels = \"A\")\np\n\n\n\n\n\n\n\nCode\np1 &lt;- VlnPlot(sobj, \n              features = c(\"log10genes_per_UMI\"), \n              ncol = 1, \n              assay = \"RNA\", \n              group.by = \"orig.ident\", \n              cols = sample_colors, \n              stack = FALSE) & geom_hline(yintercept = 0.8, col=\"blue\") & \n              annotate(\"text\", x=0.7, y=0.81, label=\"0.8\", size=3,color = \"blue\")  \n\n# Visualize the overall complexity of the gene expression by visualizing the genes detected per UMI\n# novelty score: ratio Genes/UMI\n# highUMI & low Genes = only little genes, sequences over again == low complexity/novelty; associated to cell type? or  artifact?\n# above 0.8\np2 &lt;- sobj@meta.data %&gt;%\n  ggplot(aes(x=log10genes_per_UMI, color = orig.ident, fill=orig.ident)) +\n  geom_density(alpha = 0.2) +\n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) +\n  theme_classic() +\n  geom_vline(xintercept = 0.8) & NoLegend()\n\np &lt;- p1 + p2 + plot_layout(\n    ncol = 2, guides = \"collect\") + plot_annotation(\n        title = \"Before filtering\", \n        tag_levels = \"A\")\np\nrm(sobj)"
  },
  {
    "objectID": "analysis/02_quality_control.html#post-filtering-1-qc-metrics",
    "href": "analysis/02_quality_control.html#post-filtering-1-qc-metrics",
    "title": "Quality control",
    "section": "Post filtering #1 QC metrics",
    "text": "Post filtering #1 QC metrics\n\n\nCode\nload(paste0(proj_dir, \"/output/processed/02_SI_sobj_qc.Robj\"))\np1 &lt;- VlnPlot(filtered_sobj, \n              features = c(\"nFeature_RNA\"), \n              ncol = 1, assay = \"RNA\", \n              group.by = \"orig.ident\", \n              cols = sample_colors, \n              stack = FALSE) \np2 &lt;- VlnPlot(filtered_sobj, \n              features = c(\"nCount_RNA\"), \n              ncol = 1, \n              assay = \"RNA\", \n              group.by = \"orig.ident\",\n              cols = sample_colors, \n              stack = FALSE)  \np3 &lt;- VlnPlot(filtered_sobj, \n              features = c(\"percent.mt\"),\n             ncol = 1, \n              assay = \"RNA\", \n              group.by = \"orig.ident\", \n              cols = sample_colors, \n              stack = FALSE) \n\np4 &lt;- VlnPlot(filtered_sobj, \n              features = c(\"log10genes_per_UMI\"), \n              ncol = 1, \n              assay = \"RNA\", \n              group.by = \"orig.ident\", \n              cols = sample_colors, \n              stack = FALSE) \n\n# Visualize the distribution of genes detected per cell via histogram\n  # single peak represents cells encapsulated\n  # shoulder/bimodal distribution: 1.cells that failed, 2. biologically different types (quiescent cells, less complex cells,size)\np5 &lt;- filtered_sobj@meta.data  %&gt;% \n  ggplot(aes(color=orig.ident, x=nFeature_RNA, fill= orig.ident)) + \n  geom_density(alpha = 0.2) + \n  theme_classic() +\n  scale_x_log10() + \n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) + geom_vline(xintercept = 4000) +\n  geom_vline(xintercept = 300) & NoLegend()\n\n\n# Visualize the number UMIs/transcripts per cell\n  # UMI count should be above 500 low-end, expected\n  # between 500-1000 counts, usable should have been sequenced more deeply\np6 &lt;- filtered_sobj@meta.data %&gt;% \n  ggplot(aes(color=orig.ident, x=nCount_RNA, fill= orig.ident)) + \n  geom_density(alpha = 0.2) + \n  scale_x_log10() + \n  theme_classic() +\n  ylab(\"Cell density\") +\n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) + geom_vline(xintercept = 500) + \n  geom_vline(xintercept = 20000) + \n  NoLegend()\n\n# Visualize the distribution of mitochondrial gene expression detected per cell\n  # indication if there's large amount of mito-contamination f. dead/dying cells, above 0.2 mito ratio mark poor quality, unless expected differently \n\np7 &lt;- filtered_sobj@meta.data %&gt;%\n  ggplot(aes(color=orig.ident, x=percent.mt, fill=orig.ident)) + \n  geom_density(alpha = 0.2) + \n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) +\n  scale_x_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 5) & NoLegend()\n\n\n# Visualize the overall complexity of the gene expression by visualizing the genes detected per UMI\n  # novelty score: ratio Genes/UMI\n  # highUMI & low Genes = only little genes, sequences over again == low complexity/novelty; associated to cell type? or  artifact?\n  # above 0.8\np8 &lt;- filtered_sobj@meta.data %&gt;%\n  ggplot(aes(x=log10genes_per_UMI, color = orig.ident, fill=orig.ident)) +\n  geom_density(alpha = 0.2) +\n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) +\n  theme_classic() +\n  geom_vline(xintercept = 0.8) & NoLegend()\n\n\np &lt;- p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8 + plot_layout(\n    ncol = 4, guides = \"collect\") + plot_annotation(\n        title = \"After filtering\", \n        tag_levels = \"A\")\np\nrm(filtered_sobj)\n\n\n\nWe have removed some extreme outliers but QC is always an iterative process, so we will look at some more factors to ensure only quality cells remain. We will also fine tune QC to set some sample-specific thresholds.\nCells with high nCount_RNA and nFeature_RNA are retained for now as they help in simulating doublets.\nWe will check for doublets next."
  },
  {
    "objectID": "analysis/02_quality_control.html#post-filtering-2-qc-metrics",
    "href": "analysis/02_quality_control.html#post-filtering-2-qc-metrics",
    "title": "Quality control",
    "section": "Post filtering #2 QC metrics",
    "text": "Post filtering #2 QC metrics\n\n\nCode\nload(paste0(proj_dir, \"/output/processed/02_SI_sobj_post_df.Robj\"))\np1 &lt;- VlnPlot(sobj_post_df, \n              features = c(\"nFeature_RNA\"), \n              ncol = 1, assay = \"RNA\", \n              group.by = \"orig.ident\", \n              cols = sample_colors, \n              stack = FALSE) \np2 &lt;- VlnPlot(sobj_post_df, \n              features = c(\"nCount_RNA\"), \n              ncol = 1, \n              assay = \"RNA\", \n              group.by = \"orig.ident\",\n              cols = sample_colors, \n              stack = FALSE)  \np3 &lt;- VlnPlot(sobj_post_df, \n              features = c(\"percent.mt\"),\n             ncol = 1, \n              assay = \"RNA\", \n              group.by = \"orig.ident\", \n              cols = sample_colors, \n              stack = FALSE) \n\np4 &lt;- VlnPlot(sobj_post_df, \n              features = c(\"log10genes_per_UMI\"), \n              ncol = 1, \n              assay = \"RNA\", \n              group.by = \"orig.ident\", \n              cols = sample_colors, \n              stack = FALSE) \n\n# Visualize the distribution of genes detected per cell via histogram\n  # single peak represents cells encapsulated\n  # shoulder/bimodal distribution: 1.cells that failed, 2. biologically different types (quiescent cells, less complex cells,size)\np5 &lt;- sobj_post_df@meta.data  %&gt;% \n  ggplot(aes(color=orig.ident, x=nFeature_RNA, fill= orig.ident)) + \n  geom_density(alpha = 0.2) + \n  theme_classic() +\n  scale_x_log10() + \n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) + geom_vline(xintercept = 4000) +\n  geom_vline(xintercept = 300) & NoLegend()\n\n\n# Visualize the number UMIs/transcripts per cell\n  # UMI count should be above 500 low-end, expected\n  # between 500-1000 counts, usable should have been sequenced more deeply\np6 &lt;- sobj_post_df@meta.data %&gt;% \n  ggplot(aes(color=orig.ident, x=nCount_RNA, fill= orig.ident)) + \n  geom_density(alpha = 0.2) + \n  scale_x_log10() + \n  theme_classic() +\n  ylab(\"Cell density\") +\n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) + geom_vline(xintercept = 500) + \n  geom_vline(xintercept = 20000) + \n  NoLegend()\n\n# Visualize the distribution of mitochondrial gene expression detected per cell\n  # indication if there's large amount of mito-contamination f. dead/dying cells, above 0.2 mito ratio mark poor quality, unless expected differently \n\np7 &lt;- sobj_post_df@meta.data %&gt;%\n  ggplot(aes(color=orig.ident, x=percent.mt, fill=orig.ident)) + \n  geom_density(alpha = 0.2) + \n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) +\n  scale_x_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 5) & NoLegend()\n\n\n# Visualize the overall complexity of the gene expression by visualizing the genes detected per UMI\n  # novelty score: ratio Genes/UMI\n  # highUMI & low Genes = only little genes, sequences over again == low complexity/novelty; associated to cell type? or  artifact?\n  # above 0.8\np8 &lt;- sobj_post_df@meta.data %&gt;%\n  ggplot(aes(x=log10genes_per_UMI, color = orig.ident, fill=orig.ident)) +\n  geom_density(alpha = 0.2) +\n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) +\n  theme_classic() +\n  geom_vline(xintercept = 0.8) & NoLegend()\n\n# FeatureScatter plot for nCount_RNA vs nFeature_RNA\n# Generate the FeatureScatter plot as a ggplot object\np9 &lt;- FeatureScatter(\n    object = sobj_post_df, \n    group.by = \"orig.ident\",\n    split.by = NULL,\n    feature1 = \"nCount_RNA\", \n    cols = sample_colors,\n    feature2 = \"nFeature_RNA\", \n    shuffle = TRUE, \n    plot.cor = FALSE\n)\n\np9 &lt;- p9 + \n    geom_vline(xintercept = 500, color = \"blue\", linetype = \"dashed\") + \n    geom_vline(xintercept = 20000, color = \"red\", linetype = \"dashed\") + \n    geom_hline(yintercept = 300, color = \"blue\", linetype = \"dashed\") + \n    geom_hline(yintercept = 4000, color = \"red\", linetype = \"dashed\") + \n    annotate(\"text\", x = 500, y = 3500, \n             label = \"500\", color = \"blue\", vjust = -0.5, hjust = -0.1, angle = 90) +\n  annotate(\"text\", x = 20000, y = 2500, \n             label = \"20000\", color = \"red\", vjust = -0.5, hjust = -0.1, angle = 90) +\n    annotate(\"text\", x = 19000, y = 300, \n             label = \"300\", color = \"blue\", vjust = -0.5, hjust = -0.1) +\n  annotate(\"text\", x = 500, y = 3700, \n             label = \"4000\", color = \"red\", vjust = -0.5, hjust = -0.1) \n\n# FeatureScatter plot for nCount_RNA vs percent.mt\np10 &lt;- FeatureScatter(\n    object = sobj_post_df, \n    group.by = \"orig.ident\",\n    split.by = NULL,\n    feature1 = \"nFeature_RNA\", \n    cols = sample_colors,\n    feature2 = \"percent.mt\", \n    shuffle = TRUE, \n    plot.cor = FALSE\n)  \n\np10 &lt;- p10 + \n    geom_vline(xintercept = 300, color = \"blue\", linetype = \"dashed\") + \n    geom_vline(xintercept = 4000, color = \"red\", linetype = \"dashed\") + \n    geom_hline(yintercept = 5, color = \"red\", linetype = \"dashed\") + \n    annotate(\"text\", x = 300, y = 4, \n             label = \"300\", color = \"blue\", vjust = -0.5, hjust = -0.1, angle = 90) +\n    annotate(\"text\", x = 4000, y = 4.9, \n             label = \"5%\", color = \"red\", vjust = -0.5, hjust = -0.1) +\n    annotate(\"text\", x = 4000, y = 4, \n             label = \"4000\", color = \"red\", vjust = -0.5, hjust = -0.1, angle = 90)\n\np &lt;- p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8 + plot_layout(\n    ncol = 4, guides = \"collect\") + plot_annotation(\n        title = \"After filtering\", \n        tag_levels = \"A\")\np\n\np &lt;- p9 + p10 + plot_layout(\n    ncol = 2, guides = \"collect\") + plot_annotation(\n        title = \"After filtering\", \n        tag_levels = \"A\")\np"
  },
  {
    "objectID": "analysis/02_quality_control.html#gene-expression",
    "href": "analysis/02_quality_control.html#gene-expression",
    "title": "Quality control",
    "section": "Gene expression",
    "text": "Gene expression\nThe relationship between the number of cells that express a gene and the overall expression level can be interesting. We expect to see that higher expressed genes are expressed in more cells but there may be some that stand out from this. Since we already filtered out genes that were expressed in less than 5 cells, we dont expect outliers in that direction.\n\n\nCode\n# Get raw or normalized expression data\nexpr_data &lt;- GetAssayData(sobj_post_df, slot = \"data\")  # Log-normalized counts\n\n# Calculate percentage of cells expressing each gene\npct_cells_expressing &lt;- rowSums(expr_data &gt; 0) / ncol(expr_data) * 100  # Percentage\n\n# Calculate mean expression for each gene\nmean_expression &lt;- rowMeans(expr_data)\n\n# Combine into a data frame\ngene_stats &lt;- data.frame(\n  Gene = rownames(expr_data),\n  PctCellsExpressing = pct_cells_expressing,\n  MeanExpression = mean_expression\n)\n\n# Count genes expressed in at least 50% and 25% of cells\ngenes_50 &lt;- sum(gene_stats$PctCellsExpressing &gt;= 50)\ngenes_25 &lt;- sum(gene_stats$PctCellsExpressing &gt;= 25)\n\n# Create the plot with axes switched\np_gene_exp &lt;- ggplot(gene_stats, aes(x = PctCellsExpressing, y = MeanExpression)) +\n  geom_point(alpha = 0.6) +  # Scatter points\n  geom_smooth(color = \"red\", se = TRUE) +  # Trend line\n  geom_vline(xintercept = 50, linetype = \"dashed\", color = \"blue\") +  \n  annotate(\"text\", x = 47, y = 3,\n           label = paste0(genes_50, \" genes ≥ 50%\"), hjust = 0, angle = 90) +\n  geom_vline(xintercept = 25, linetype = \"dashed\", color = \"blue\") +  \n  annotate(\"text\", x = 22, y = 3, \n           label = paste0(genes_25, \" genes ≥ 25%\"), hjust = 0, angle = 90) +\n  scale_x_continuous(name = \"Percentage of cells expressing\", limits = c(0, 100)) +\n  scale_y_continuous(name = \"Mean expression\") +\n  theme_minimal()\np_gene_exp\n#The outlier gene expressed in 100% cells and mean exp 5 is Gm42418"
  },
  {
    "objectID": "analysis/02_quality_control.html#gene-variance",
    "href": "analysis/02_quality_control.html#gene-variance",
    "title": "Quality control",
    "section": "Gene variance",
    "text": "Gene variance\nThis plot shows the percentage of variance in the dataset that is explained by various technical factors. I am using the variancePartition package which is designed to estimate the contribution of different factors to the variance of each gene’s expression across the dataset to quantify how much each factor (e.g., sample, technical effects) contributes to the total variation in gene expression.\nFor each gene in the dataset, it fits a linear mixed model (LMM) where the expression of the gene is modeled as a function of multiple explanatory variables (factors). The output is the percentage of variance in the gene’s expression that can be attributed to each factor, in other words, the proportion of variance explained by each factor per gene.\nThis is another way of validating our gene filtering. If the variance in a lot of genes is explained by technical factors, then we have to reconsider our filters.\n\n\nCode\nload(paste0(proj_dir, \"/output/processed/02_SI_variancePartition.Robj\"))\n# Figure 1a\n# Bar plot of variance fractions for the first 10 genes\n# plotPercentBars(vp[1:10, ])\n\n# Variance explained by different technical factors\nplotVarPart(vp)\n\n# # Calculate variance explained by sample (categorical)\n# form &lt;- ~ (1 | sample) + (1 | SelMethod) \n# varPart_cat &lt;- fitExtractVarPartModel(expr_data, form, meta_data)\n# \n# # sort variables (i.e. columns) by median fraction\n# #       of variance explained\n# vp &lt;- sortCols(varPart)\n# \n# # Figure 1a\n# # Bar plot of variance fractions for the first 10 genes\n# # plotPercentBars(vp[1:10, ])\n# \n# plotVarPart(vp)\n\n\n\nSince most of the variance in gene expression in the dataset is explained by residuals, this means that we did not introduce any bias."
  },
  {
    "objectID": "analysis/02_quality_control.html#pca-outliers",
    "href": "analysis/02_quality_control.html#pca-outliers",
    "title": "Quality control",
    "section": "PCA outliers",
    "text": "PCA outliers\nAnother approach to validate our filters is to perform a PCA using technical factors instead of gene expression and then use outlier detection to identify low-quality cells.\n\n\nCode\nload(paste0(proj_dir, \"/output/processed/02_SI_sobj_post_df.Robj\"))\n# Define technical factors\ntechnical_factors &lt;- c(\"nCount_RNA\", \"nFeature_RNA\")\n\n# Subset metadata for PCA\nmeta_data_pca &lt;- sobj_post_df@meta.data[, technical_factors]\n\n# Perform PCA using prcomp\npca_result &lt;- prcomp(meta_data_pca, scale. = TRUE)\nsummary(pca_result)  \n\n# Add PCA embeddings to the metadata\npca_embeddings &lt;- as.data.frame(pca_result$x)\ncolnames(pca_embeddings) &lt;- paste0(\"PC_\", 1:ncol(pca_embeddings))\nsobj_post_df@meta.data &lt;- cbind(sobj_post_df@meta.data, pca_embeddings)\n\n# Calculate Z-scores for the first principal component\nsobj_post_df@meta.data$outlier_nCountRNA &lt;- abs(scale(sobj_post_df@meta.data$PC_1)) &gt; 3  # Threshold: Z &gt; 3\n\n# Calculate Z-scores for the second principal component\nsobj_post_df@meta.data$outlier_nFeatureRNA &lt;- abs(scale(sobj_post_df@meta.data$PC_2)) &gt; 4  # Threshold: Z &gt; 4\n\n# Create a new column indicating whether the sample is an outlier in either condition\nsobj_post_df@meta.data$outlier &lt;- sobj_post_df@meta.data$outlier_nCountRNA | sobj_post_df@meta.data$outlier_nFeatureRNA\n\n# Scatter plot of PCA results\nggplot(sobj_post_df@meta.data, aes(x = PC_1, y = PC_2, color = outlier)) +\n  geom_point(alpha = 0.6) +\n  theme_minimal() +\n  scale_color_manual(values = c(\"FALSE\" = \"grey\", \"TRUE\" = \"red\")) +\n  labs(x = \"PC 1\", y = \"PC 2\", color = \"Outlier\")\n\ntable(sobj_post_df@meta.data$outlier)\n\n\n\nSince we don’t see any egregious outliers, our filtering did not introduce any bias."
  },
  {
    "objectID": "analysis/02_quality_control.html#kept-vs-lost",
    "href": "analysis/02_quality_control.html#kept-vs-lost",
    "title": "Quality control",
    "section": "Kept vs Lost",
    "text": "Kept vs Lost\nOne more thing we can look at is the expression level of genes between kept and removed cells. If we see known genes that are highly expressed in the removed cells that can indicate that we have removed an interesting population of cells from the dataset. The red line shows equal expression and the blue line is a linear fit.\n\nX-Axis (LostCapped): Log average gene expression in removed cells.\nY-Axis (KeptCapped): Log average gene expression in kept cells.\nColor (LostProp - KeptProp): Difference in proportion of cells expressing each gene between removed and kept populations. Positive values indicate a gene is more frequently expressed in the removed cells and vice versa. Since most genes are negative, it means they are more prevalent in kept cells!\nRed Line: LostCapped = KeptCapped, indicating genes expressed equally in both removed and kept cells. Genes significantly above red line are more expressed in the kept cells and vice versa. Majority of points cluster around the red line, especially for highly expressed genes. This is what we expect. There are some genes that have low average expression in removed cells (bottom right section under the red line) - these genes are typically indicative of poor quality cells (stressed, damaged, or empty droplets).\nBlue Line: Linear fit showing overall trend between gene expression in removed vs. kept. The relationship is linear, so this is good - our filtering did not introduce any outliers!\n\n\n\nCode\nload(paste0(proj_dir, \"/output/processed/02_SI_sobj_scale.Robj\"))\n\n# Determine which cells are kept\npass_qc &lt;- colnames(sobj) %in% colnames(sobj_post_df)\n\n# Add the pass_qc information to metadata\nsobj$pass_qc &lt;- pass_qc\n\nsave(sobj, file=\"/home/nsingh/sterile_inflammation/output/processed/02_SI_sobj_scale_pass_qc.Robj\")\n\n\n\n\nCode\nload(paste0(proj_dir, \"/output/processed/02_SI_sobj_scale_pass_qc.Robj\"))\n\nlibrary(tibble)\nlibrary(dplyr)\n\n# Determine which cells are kept\npass_qc &lt;- colnames(sobj) %in% colnames(sobj_post_df)\n\n# Separate counts for kept and lost cells\nlost_counts &lt;- as.matrix(sobj@assays[[\"RNA\"]]@layers[[\"counts\"]][, !pass_qc])\nkept_counts &lt;- as.matrix(sobj@assays[[\"RNA\"]]@layers[[\"counts\"]][, pass_qc])\n\n# Check dimensions of lost and kept counts\ncat(\"Lost counts dimensions: \", dim(lost_counts), \"\\n\")\ncat(\"Kept counts dimensions: \", dim(kept_counts), \"\\n\")\n\n# Calculate average expression and detection proportion\nkept_lost &lt;- tibble(\n    Gene     = rownames(sobj),\n    Lost     = rowMeans(lost_counts),\n    LostProp = rowSums(lost_counts &gt; 0) / ncol(lost_counts),\n    Kept     = rowMeans(kept_counts),\n    KeptProp = rowSums(kept_counts &gt; 0) / ncol(kept_counts)\n) %&gt;%\n    # Calculate log fold change using a pseudo count for stability\n    mutate(LogFC = log2((Kept + 1) / (Lost + 1))) %&gt;%\n    # Add capped values for stability in log-scale plots\n    mutate(\n        LostCapped = pmax(Lost, min(Lost[Lost &gt; 0]) * 0.5),\n        KeptCapped = pmax(Kept, min(Kept[Kept &gt; 0]) * 0.5)\n    )\n\nlibrary(viridis)\n\n# Plot\nggplot(kept_lost,\n       aes(x = LostCapped, y = KeptCapped, colour = LostProp - KeptProp)) +\n    geom_point(size = 1, alpha = 0.2) +\n    geom_abline(intercept = 0, slope = 1, colour = \"red\") +  # Red line for equality\n    geom_smooth(method = \"lm\", colour = \"blue\") +            # Blue line for linear fit\n    scale_x_log10() +\n    scale_y_log10() +\n    scale_colour_viridis_c() +\n    xlab(\"Average count (removed)\") +\n    ylab(\"Average count (kept)\") +\n    theme_minimal()\n\nkept_lost %&gt;%\n    select(Gene, LogFC, Lost, LostProp, Kept, KeptProp) %&gt;%\n    arrange(-LogFC) %&gt;%\n    as.data.frame() %&gt;%\n    head(100)"
  },
  {
    "objectID": "analysis/02_quality_control.html#thresholds",
    "href": "analysis/02_quality_control.html#thresholds",
    "title": "Quality control",
    "section": "Thresholds",
    "text": "Thresholds\n\n\nCode\nload(paste0(proj_dir, \"/output/processed/02_SI_sobj_scale.Robj\"))\n\n# Thresholds\nfeature_lower &lt;- 300\nfeature_upper &lt;- 4000\ncount_lower &lt;- 500\ncount_upper &lt;- 20000\nmt_thresh &lt;- 5\nlog10genes_thresh &lt;- 0.8\n\n# Filtering results from the steps provided\nfilter_steps &lt;- data.frame(\n  Step = c(\n    \"Initial Cells\", \n    \"nFeature_RNA &gt; 300\", \n    \"nCount_RNA &gt; 500\",\n    \"log10genes_per_UMI &gt; 0.80\", \n    \"percent.mt &lt; 5\",\n    \"Doublets Removed\",\n    \"nFeature_RNA &lt; 4000\",\n    \"nCount_RNA &lt; 20000\"\n  ),\n  Remaining_Cells = c(46155, 39911, 39249, 39231, 36838, 34824, 34708, 34694),\n  Removed_Cells = c(NA, -6244, -662, -18, -2393, -2014, -116, -14)\n)\n\n# Add metadata column for \"Kept\" based on all thresholds\nsobj@meta.data &lt;- sobj@meta.data %&gt;%\n  mutate(\n    Kept = nFeature_RNA &gt; feature_lower & nFeature_RNA &lt; feature_upper &\n           nCount_RNA &gt; count_lower & nCount_RNA &lt; count_upper &\n           percent.mt &lt; mt_thresh & log10genes_per_UMI &gt; log10genes_thresh\n  )\n\n# Prepare data for the Counts vs Features plot\nplot_data &lt;- sobj@meta.data\n\n# Add filtering thresholds and removed cell info to the Counts vs Features plot\nexp_plot &lt;- ggplot(plot_data, aes(x = nCount_RNA, y = nFeature_RNA, colour = Kept)) +\n  geom_point(alpha = 0.3) +\n  geom_vline(xintercept = count_lower, linetype = \"dashed\", colour = \"#8DC63F\") +\n  geom_vline(xintercept = count_upper, linetype = \"dashed\", colour = \"#8DC63F\") +\n  geom_hline(yintercept = feature_lower, linetype = \"dashed\", colour = \"#7A52C7\") +\n  geom_hline(yintercept = feature_upper, linetype = \"dashed\", colour = \"#7A52C7\") +\n  annotate(\"text\", x = count_lower, y = Inf, label = paste(\"Removed:\", -filter_steps$Removed_Cells[3]),\n           angle = 90, vjust = -0.5, hjust = 1, colour = \"#8DC63F\") +\n  annotate(\"text\", x = count_upper, y = Inf, label = paste(\"Removed:\", -filter_steps$Removed_Cells[8]),\n           angle = 90, vjust = -0.5, hjust = 1, colour = \"#8DC63F\") +\n  annotate(\"text\", x = Inf, y = feature_lower, label = paste(\"Removed:\", -filter_steps$Removed_Cells[2]),\n           vjust = -0.5, hjust = 1, colour = \"#7A52C7\") +\n  annotate(\"text\", x = Inf, y = feature_upper, label = paste(\"Removed:\", -filter_steps$Removed_Cells[7]),\n           vjust = -0.5, hjust = 1, colour = \"#7A52C7\") +\n  scale_colour_manual(values = c(\"#EC008C\", \"#00ADEF\"), labels = c(\"Removed\", \"Kept\")) +\n  labs(x = \"nCount_RNA\", y = \"nFeature_RNA\", colour = \"\", title = \"nCount_RNA (300-20,000) vs nFeature_RNA (500-4000)\") +\n  theme_minimal()\n\n# Add filtering thresholds and removed cell info to the Mitochondrial percentage plot\nmt_plot &lt;- ggplot(plot_data, aes(x = percent.mt)) +\n  geom_histogram(bins = 100, fill = \"#7A52C7\", alpha = 0.7) +\n  geom_vline(xintercept = mt_thresh, linetype = \"dashed\", colour = \"#EC008C\") +\n  annotate(\"text\", x = 8, y = Inf, label = paste(\"Removed:\", -filter_steps$Removed_Cells[5]),\n           angle = 90, vjust = -0.5, hjust = 1, colour = \"#EC008C\") +\n  labs(x = \"Percentage mitochondrial\", y = \"Number of cells\", title = \"Mitochondrial content (&lt;5%)\") +\n  theme_minimal()\n\n# Add filtering thresholds and removed cell info to the log10 Genes per UMI plot\numi_plot &lt;- ggplot(plot_data, aes(x = log10genes_per_UMI)) +\n  geom_histogram(bins = 100, fill = \"#00ADEF\", alpha = 0.7) +\n  geom_vline(xintercept = log10genes_thresh, linetype = \"dashed\", colour = \"#EC008C\") +\n  annotate(\"text\", x = log10genes_thresh, y = Inf, label = paste(\"Removed:\", -filter_steps$Removed_Cells[4]),\n           angle = 90, vjust = -0.5, hjust = 1, colour = \"#EC008C\") +\n  labs(x = \"Log10 genes per UMI\", y = \"Number of cells\", title = \"Log10 genes per UMI (&lt;0.8)\") +\n  theme_minimal()\n\n# Use cowplot to add the annotation near the legend\np_doublets &lt;- ggdraw(p_doublets) + ggtitle(\"Doublets: removed 2014\")\n\n# Combine all plots into a single figure\nfig &lt;- plot_grid(\n  exp_plot, mt_plot, umi_plot, p_doublets,\n  labels = \"AUTO\", ncol = 2\n)\nfig"
  },
  {
    "objectID": "analysis/02_quality_control.html#validation-1",
    "href": "analysis/02_quality_control.html#validation-1",
    "title": "Quality control",
    "section": "Validation",
    "text": "Validation\n\n\nCode\nload(paste0(proj_dir, \"/output/processed/02_SI_sobj_scale_pass_qc.Robj\"))\nlibrary(ggrepel)\n\n# Determine which cells are kept\npass_qc &lt;- colnames(sobj) %in% colnames(sobj_post_df)\n\n# Separate counts for kept and lost cells\nlost_counts &lt;- as.matrix(sobj@assays[[\"RNA\"]]@layers[[\"counts\"]][, !pass_qc])\nkept_counts &lt;- as.matrix(sobj@assays[[\"RNA\"]]@layers[[\"counts\"]][, pass_qc])\n\n# Create a data frame for fold-change metrics\nkept_lost &lt;- tibble(\n  Gene     = rownames(sobj),\n  Lost     = rowMeans(lost_counts),\n  LostProp = rowSums(lost_counts &gt; 0) / ncol(lost_counts),\n  Kept     = rowMeans(kept_counts),\n  KeptProp = rowSums(kept_counts &gt; 0) / ncol(kept_counts),\n  LogFC    = log2((rowMeans(kept_counts) + 1) / (rowMeans(lost_counts) + 1))\n)\n\n# Select the top 10 genes highly expressed in removed cells (lowest LogFC)\ntop_removed_genes &lt;- kept_lost %&gt;%\n  arrange(LogFC) %&gt;%\n  slice_head(n = 10)\n\n# Select the top 10 genes highly expressed in kept cells (highest LogFC)\ntop_kept_genes &lt;- kept_lost %&gt;%\n  arrange(desc(LogFC)) %&gt;%\n  slice_head(n = 10)\n\n# Add a column to indicate highlighted genes\nkept_lost &lt;- kept_lost %&gt;%\n  mutate(\n    Highlight = ifelse(Gene %in% c(top_removed_genes$Gene, top_kept_genes$Gene), Gene, NA)\n  )\n\n# Plot with highlighted genes\nfc_plot &lt;- ggplot(kept_lost, aes(x = 0.5 * (Lost + Kept), y = LogFC, colour = LostProp - KeptProp)) +\n  geom_point(alpha = 0.3) +\n  geom_hline(yintercept = 0, colour = \"red\") +\n  scale_x_log10(labels = scales::number_format(accuracy = 0.0001)) +\n  scale_colour_viridis_c(name = \"Prop expressed (Removed) - Prop expressed (Kept)\") +\n  ggtitle(\"Fold-change between removed and kept cells\") +\n  xlab(\"0.5 * (Average expression (Kept) + Average expression (Removed))\") +\n  ylab(\"Predicted log2 fold-change (Removed / Kept)\") +\n  theme_minimal() +\n  theme(legend.position = \"bottom\") +\n  # Add labels for the top 10 genes\n  geom_text_repel(\n    data = filter(kept_lost, !is.na(Highlight)),\n    aes(label = Highlight),\n    max.overlaps = 10, colour = \"black\", size = 3\n  )\n\n# Create a table for top fold-change genes\nfc_table &lt;- kept_lost %&gt;%\n  select(Gene, LogFC) %&gt;%\n  arrange(-LogFC) %&gt;%\n  head(15) %&gt;%\n  tableGrob(rows = NULL, theme = ttheme_minimal())\n\nfeature_plots &lt;- list(\n  FeaturePlot(sobj_post_df, features = \"nCount_RNA\") +\n    scale_colour_viridis_c() +\n    ggtitle(\"nCount_RNA\") + NoAxes() + NoLegend(),\n  FeaturePlot(sobj_post_df, features = \"nFeature_RNA\") +\n    scale_colour_viridis_c() +\n    ggtitle(\"nFeature_RNA\") + \n    NoAxes() + NoLegend(),\n  FeaturePlot(sobj_post_df, features = \"percent.mt\") +\n    scale_colour_viridis_c() +\n    ggtitle(\"% mito\") +\n    NoAxes() + NoLegend(),\n  FeaturePlot(sobj_post_df, features = \"log10genes_per_UMI\") +\n    scale_colour_viridis_c() +\n    ggtitle(\"Log10 genes per UMI\") +\n    NoAxes() + NoLegend()\n)\n\n# Combine plots into a grid (2 columns)\numap_plot &lt;- wrap_plots(feature_plots, ncol = 2)\n\n# Combine fold-change plot and table\np1 &lt;- plot_grid(fc_plot, ncol = 1, labels = \"AUTO\")\n\n# Combine fold-change section with UMAP plots\nfig &lt;- plot_grid(p1, umap_plot, ncol = 2, labels = c(\"\", \"B\"),\n                 rel_heights = c(0.8, 1))\n\n# Display the figure\nfig"
  },
  {
    "objectID": "analysis/02_quality_control.html#parameters",
    "href": "analysis/02_quality_control.html#parameters",
    "title": "Quality control",
    "section": "Parameters",
    "text": "Parameters\nThis table describes parameters used and set in this document.\n\n\nCode\n# Filtering results from the steps provided\nfilter_steps &lt;- data.frame(\n  Step = c(\n    \"Initial Cells\", \n    \"nFeature_RNA &gt; 300\", \n    \"nCount_RNA &gt; 500\",\n    \"log10genes_per_UMI &gt; 0.80\", \n    \"percent.mt &lt; 5\",\n    \"Doublets Removed\",\n    \"nFeature_RNA &lt; 4000\",\n    \"nCount_RNA &lt; 20000\"\n  ),\n  Remaining_Cells = c(46155, 39911, 39249, 39231, 36838, 34824, 34708, 34694),\n  Removed_Cells = c(NA, -6244, -662, -18, -2393, -2014, -116, -14)\n)\n\n# Define the parameter descriptions and thresholds\nparameter_descriptions &lt;- c(\n  \"Initial number of cells before filtering\",\n  \"Filter for cells with detected features above a minimum threshold\",\n  \"Filter for cells with total RNA counts above a minimum threshold\",\n  \"Filter for cells with sufficient gene complexity (log10 genes per UMI)\",\n  \"Filter for cells with mitochondrial percentage below a maximum threshold\",\n  \"Remove doublets identified using DoubletFinder\",\n  \"Filter for cells with detected features below a maximum threshold\",\n  \"Filter for cells with total RNA counts below a maximum threshold\"\n)\n\nthresholds &lt;- c(\n  NA,  # Initial step has no threshold\n  \"&gt; 300\", \n  \"&gt; 500\", \n  \"&gt; 0.80\", \n  \"&lt; 5%\", \n  \"N/A\",  # Doublet removal isn't tied to a threshold\n  \"&lt; 4000\", \n  \"&lt; 20000\"\n)\n\n# Create the table\nfilter_table &lt;- data.frame(\n  Parameter = c(\"Initial Cells\", \"nFeature_RNA\", \"nCount_RNA\", \"log10genes_per_UMI\", \"percent.mt\", \"Doublets\", \"nFeature_RNA\", \"nCount_RNA\"),\n  Description = parameter_descriptions,\n  Threshold = thresholds,\n  Cells_removed = abs(filter_steps$Removed_Cells),  # Absolute value for cells removed\n  Cells_remaining = filter_steps$Remaining_Cells\n)\n\nparams &lt;- jsonlite::toJSON(filter_table, pretty = TRUE)\nknitr::kable(jsonlite::fromJSON(params))\n\n\n\n\n\n\n\n\n\n\n\n\nParameter\nDescription\nCells_remaining\nThreshold\nCells_removed\n\n\n\n\nInitial Cells\nInitial number of cells before filtering\n46155\nNA\nNA\n\n\nnFeature_RNA\nFilter for cells with detected features above a minimum threshold\n39911\n&gt; 300\n6244\n\n\nnCount_RNA\nFilter for cells with total RNA counts above a minimum threshold\n39249\n&gt; 500\n662\n\n\nlog10genes_per_UMI\nFilter for cells with sufficient gene complexity (log10 genes per UMI)\n39231\n&gt; 0.80\n18\n\n\npercent.mt\nFilter for cells with mitochondrial percentage below a maximum threshold\n36838\n&lt; 5%\n2393\n\n\nDoublets\nRemove doublets identified using DoubletFinder\n34824\nN/A\n2014\n\n\nnFeature_RNA\nFilter for cells with detected features below a maximum threshold\n34708\n&lt; 4000\n116\n\n\nnCount_RNA\nFilter for cells with total RNA counts below a maximum threshold\n34694\n&lt; 20000\n14\n\n\n\n\n\nCode\n#write.csv(filter_table, \"./output/data/02_SI_qc_steps_summary.csv\", row.names = FALSE)"
  },
  {
    "objectID": "analysis/02_quality_control.html#output-files",
    "href": "analysis/02_quality_control.html#output-files",
    "title": "Quality control",
    "section": "Output files",
    "text": "Output files\nThis table describes the output files produced by this document. Right click and Save Link As… to download the results (to be implemented).\n\n\nCode\nsaved_files &lt;- extract_saved_files(\"./analysis/02_quality_control.qmd\")\n#saved_files &lt;- saved_files[-c(1, 2), ]\nprint(saved_files)\nwrite.csv(saved_files, file = paste0(proj_dir, \"/output/data/02_SI_saved_files_summary.csv\"))\n\n\n\n\nCode\nsaved_files &lt;- read.csv(file = paste0(proj_dir, \"/output/data/02_SI_saved_files_summary.csv\"))\nparams &lt;- jsonlite::toJSON(saved_files, pretty = TRUE)\nknitr::kable(jsonlite::fromJSON(params))\n\n\n\n\n\n\n\n\n\n\n\nX\nFile\nDirectory\nDescription\n\n\n\n\n1\nselected\nfile=here::here(output/processed/02_SI_selected.Robj)\nSCE obj, add lib size, normalize\n\n\n2\nsobj\nfile=/home/nsingh/sterile_inflammation/output/processed/02_SI_sobj.Robj\ninitial SO, unfiltered\n\n\n3\nsobj\nfile=/home/nsingh/sterile_inflammation/output/processed/02_SI_sobj_scale.Robj\ninitial SO; unfiltered, scaled\n\n\n4\nfiltered_sobj\nfile=./output/processed/02_SI_sobj_qc.Robj\nSO post filtering #1\n\n\n5\nfiltered_sobj\nfile=/home/nsingh/sterile_inflammation/output/processed/02_SI_sobj_df.Robj\nSO post doublet finder\n\n\n6\nsobj_post_df\nfile=./output/processed/02_SI_sobj_post_df.Robj\nSO post filtering #2\n\n\n7\nvp\nfile = ./output/processed/02_SI_variancePartition.Robj\nvariance partition on qc metrics\n\n\n8\nsobj\nfile=/home/nsingh/sterile_inflammation/output/processed/02_SI_sobj_scale_pass_qc.Robj\nintial SO, add metadata whether cells passed qc"
  },
  {
    "objectID": "analysis/03_clustering.html",
    "href": "analysis/03_clustering.html",
    "title": "Clustering",
    "section": "",
    "text": "Code\n# scRNA-seq\nlibrary(\"SingleCellExperiment\")\nlibrary(\"scater\")\nlibrary(scran)\nlibrary(\"Seurat\")\nlibrary(\"singleCellTK\")\nlibrary(\"LoomExperiment\")\n\n# Clustering trees\nlibrary(\"clustree\")\n\n# Plotting\nlibrary(\"viridis\")\nlibrary(\"ggforce\")\nlibrary(\"cowplot\")\nlibrary(ggrepel)\n\n# Presentation\nlibrary(\"knitr\")\n\n# Tidyverse\nlibrary(\"tidyverse\")\nCode\nproj_dir &lt;- \"/Users/nami/Desktop/sterile_inflammation/\"\nplots_dir &lt;- \"/Users/nami/Desktop/sterile_inflammation/output/plots/03_clustering/\"\nsobj_dir &lt;- \"/Users/nami/Desktop/sterile_inflammation/output/processed/\"\n\nsource(paste0(proj_dir,\"/functions/output.R\"))\nsource(paste0(proj_dir,\"/functions/crossover.R\"))\nsource(paste0(proj_dir,\"/functions/universal.R\"))\n\nload(paste0(sobj_dir,tag,\"_seurat_sct.Robj\"))\nload(paste0(sobj_dir,tag,\"_seurat_vst.Robj\"))\nCode\n# Define sample names\nsample_names &lt;- c(\"PVM_0h\", \"PVEU_0h\", \"PVM_4h\", \"PVEU_4h\", \"PVM_7h\", \"PVEU_7h\")\n\nsample_colors &lt;- c(\n  \"PVM_0h\"  = \"#EE9A49\",  \n  \"PVM_4h\"  = \"#CD853F\", \n  \"PVM_7h\" = \"#8B5A2B\",  \n  \"PVEU_0h\"  = \"#7EC0EE\",\n  \"PVEU_4h\" = \"#6CA6CD\", \n  \"PVEU_7h\" = \"#4A708B\"\n)"
  },
  {
    "objectID": "analysis/03_clustering.html#comparison",
    "href": "analysis/03_clustering.html#comparison",
    "title": "Clustering",
    "section": "Comparison",
    "text": "Comparison\nNow let’s examine the overalp between the 2 methods, and perform principal component analysis on both sets of genes.\n\nNumberPCA (Seurat: SCTransform)PCA (Seurat:VST)\n\n\n\n\nCode\nlibrary(UpSetR)\nvenn_list &lt;- list(\n  Find_var_features_HVGs = vars_vst,\n  scTransform_HVGs = vars_sct\n)\np &lt;- upset(fromList(venn_list),\n      order.by = \"freq\",\n      main.bar.color = \"steelblue\",\n      sets.bar.color = \"tomato\")\np\n\n\n\n\n\n\n\n\n\nCode\n# ggsave(paste0(plots_dir,tag,\"_SCT_VST_overlap.png\"),\n#        plot = p, width = 6, height = 5)\n\n\n\n\nPCA of cells using genes selected by SCTransform.\n\n\nCode\nseurat_sct &lt;- RunPCA(seurat_sct, features = vars_sct, npcs = 2,\n                 seed.use = 123, reduction.key = \"PCSCT_\")\n\n\n\n\nCode\nIdents(seurat_sct) &lt;- \"orig.ident\"\np &lt;- DimPlot(seurat_sct, reduction = \"pca\", dims = c(1,2),\n        label = FALSE, cols = sample_colors)\np\n\n\n\n\n\n\n\n\n\nCode\nggsave(paste0(plots_dir,tag,\"_SCT_PCA.png\"),\n       plot = p, width = 6, height = 5)\n\n\n\n\nPCA of cells using genes selected by Seurat’s VST.\n\n\nCode\nseurat &lt;- RunPCA(seurat, features = vars_vst, npcs = 2,\n                 seed.use = 123, reduction.key = \"PCVST_\")\n\n\n\n\nCode\nIdents(seurat) &lt;- \"orig.ident\"\np &lt;- DimPlot(seurat, reduction = \"pca\", dims = c(1,2), \n        label = FALSE, cols = sample_colors) \np\n\n\n\n\n\n\n\n\n\nCode\nggsave(paste0(plots_dir,tag,\"_VST_PCA.png\"),\n       plot = p, width = 6, height = 5)"
  },
  {
    "objectID": "analysis/03_clustering.html#seurat-sctransform-1",
    "href": "analysis/03_clustering.html#seurat-sctransform-1",
    "title": "Clustering",
    "section": "Seurat: SCTransform",
    "text": "Seurat: SCTransform\n\n\nCode\nseurat_sct &lt;- RunPCA(\n  object        = seurat_sct,\n  features      = vars_sct,\n  npcs          = 50,\n  seed.use      = 123,\n  reduction.key = \"PCSCT_\"\n)\n\n\n\nElbow and screeDim loadings 1:15Dim loadings 15:30Heatmap 1:15Heatmap 15:30Quantitative approach\n\n\n\n\nCode\np1 &lt;- ElbowPlot(seurat_sct, ndims = 50) \n\n# Compute the proportion of the total variance each PC explains\nstdevs &lt;- seurat_sct[[\"pca\"]]@stdev\nvar_per_pc &lt;- stdevs^2\nvar_explained &lt;- var_per_pc / sum(var_per_pc)\nvar_explained_percent &lt;- var_explained * 100\ndf &lt;- data.frame(\n  PC = 1:50,\n  VarianceExplained = var_explained_percent\n)\n\np2 &lt;- ggplot(df, aes(x = PC, y = VarianceExplained)) +\n  geom_line(group = 1) +         \n  geom_point() +                 \n  theme_minimal() +\n  labs(\n    title = \"\",\n    x = \"Principal component\",\n    y = \"% Variance explained\"\n  )\n\np &lt;- p1 + p2\np\n\n\n\n\n\n\n\n\n\nCode\nggsave(paste0(plots_dir,tag,\"_dims_sct_elbow.png\"),\n       plot = p, width = 6, height = 5)\n\n\n\n\n\n\nCode\np &lt;- VizDimLoadings(seurat_sct, dims = 1:15, nfeatures = 10)\np\n\n\n\n\n\n\n\n\n\nCode\nggsave(paste0(plots_dir,tag,\"_dims_sct_dim_1.png\"),\n       plot = p, width = 6, height = 5)\n\n\n\n\n\n\nCode\np &lt;- VizDimLoadings(seurat_sct, dims = 15:30, nfeatures = 10)\np\n\n\n\n\n\n\n\n\n\nCode\nggsave(paste0(plots_dir,tag,\"_dims_sct_dim_2.png\"),\n       plot = p, width = 6, height = 5)\n\n\n\n\n\n\nCode\np &lt;- DimHeatmap(seurat_sct, dims = 1:15, cells = 500, balanced = TRUE)\n\n\n\n\n\n\n\n\n\nCode\np\n\n\nNULL\n\n\nCode\nggsave(paste0(plots_dir,tag,\"_dims_sct_heatmap_1.png\"),\n       plot = p, width = 6, height = 5)\n\n\n\n\n\n\nCode\np &lt;- DimHeatmap(seurat_sct, dims = 15:30, cells = 500, balanced = TRUE)\n\n\n\n\n\n\n\n\n\nCode\np\n\n\nNULL\n\n\nCode\nggsave(paste0(plots_dir,tag,\"_dims_sct_heatmap_2.png\"),\n       plot = p, width = 6, height = 5)\n\n\n\n\n\n\nCode\nselected_dims &lt;- select_dims(seurat_sct, \"pca\")\n\n\n[1] \"Approach 1: Dims = 41\"\n[1] \"Approach 2: Dims = 13\"\n[1] \"Approach 3: Dims = 39\"\n\nSummary of Approaches:\nApproach 1: The point where PCs collectively contribute ~90% of the standard deviation and the individual PCs only contribute 5% of standard deviation.\nApproach 2: The point where the percent change in variation between consecutive PCs is &lt; 0.1%.\nApproach 3: The point where the cumulative variance explained by the PCs is at least 95%."
  },
  {
    "objectID": "analysis/03_clustering.html#seurat-vst",
    "href": "analysis/03_clustering.html#seurat-vst",
    "title": "Clustering",
    "section": "Seurat: VST",
    "text": "Seurat: VST\n\n\nCode\nseurat &lt;- RunPCA(\n  object        = seurat,\n  features      = vars_vst,\n  npcs          = 50,\n  seed.use      = 123,\n  reduction.key = \"PCVST_\"\n)\n\n\n\nElbow and screeDim loadings 1:15Dim loadings 15:30Heatmap 1:15Heatmap 1:30Quantitative approach\n\n\n\n\nCode\np1 &lt;- ElbowPlot(seurat, ndims = 50)\n\n# Compute the proportion of the total variance each PC explains\nstdevs &lt;- seurat[[\"pca\"]]@stdev\nvar_per_pc &lt;- stdevs^2\nvar_explained &lt;- var_per_pc / sum(var_per_pc)\nvar_explained_percent &lt;- var_explained * 100\ndf &lt;- data.frame(\n  PC = 1:50,\n  VarianceExplained = var_explained_percent\n)\n\np2 &lt;- ggplot(df, aes(x = PC, y = VarianceExplained)) +\n  geom_line(group = 1) +         \n  geom_point() +                 \n  theme_minimal() +\n  labs(\n    title = \"\",\n    x = \"Principal component\",\n    y = \"% Variance explained\"\n  )\n\np &lt;- p1 + p2\np\n\n\n\n\n\n\n\n\n\nCode\nggsave(paste0(plots_dir,tag,\"_dims_vst_elbow.png\"),\n       plot = p, width = 6, height = 5)\n\n\n\n\n\n\nCode\np2 &lt;- VizDimLoadings(seurat, dims = 1:15, nfeatures = 10)\np2\n\n\n\n\n\n\n\n\n\nCode\nggsave(paste0(plots_dir,tag,\"_dims_vst_dim_1.png\"),\n       plot = p2, width = 6, height = 5)\n\n\n\n\n\n\nCode\np3 &lt;- VizDimLoadings(seurat, dims = 16:30, nfeatures = 10)\np3\n\n\n\n\n\n\n\n\n\nCode\nggsave(paste0(plots_dir,tag,\"_dims_vst_dim_2.png\"),\n       plot = p3, width = 6, height = 5)\n\n\n\n\n\n\nCode\np4 &lt;- DimHeatmap(seurat, dims = 1:15, cells = 500, balanced = TRUE)\n\n\n\n\n\n\n\n\n\nCode\np4\n\n\nNULL\n\n\nCode\nggsave(paste0(plots_dir,tag,\"_dims_vst_heatmap_1.png\"),\n       plot = p4, width = 6, height = 5)\n\n\n\n\n\n\nCode\np4 &lt;- DimHeatmap(seurat, dims = 1:30, cells = 500, balanced = TRUE)\n\n\n\n\n\n\n\n\n\nCode\np4\n\n\nNULL\n\n\nCode\nggsave(paste0(plots_dir,tag,\"_dims_vst_heatmap_2.png\"),\n       plot = p4, width = 6, height = 5)\n\n\n\n\n\n\nCode\nselected_dims &lt;- select_dims(seurat, \"pca\")\n\n\n[1] \"Approach 1: Dims = 41\"\n[1] \"Approach 2: Dims = 18\"\n[1] \"Approach 3: Dims = 39\"\n\nSummary of Approaches:\nApproach 1: The point where PCs collectively contribute ~90% of the standard deviation and the individual PCs only contribute 5% of standard deviation.\nApproach 2: The point where the percent change in variation between consecutive PCs is &lt; 0.1%.\nApproach 3: The point where the cumulative variance explained by the PCs is at least 95%."
  },
  {
    "objectID": "analysis/03_clustering.html#selection",
    "href": "analysis/03_clustering.html#selection",
    "title": "Clustering",
    "section": "Selection",
    "text": "Selection\nI would like to use the quantitative approach 2 for both methods and see what clustering looks like, since there are no clear indications at this stage which method is best.\n\n\nCode\nn_pcs_sct &lt;- 13\nn_pcs_vst &lt;- 18\n\n\nBased on these plots we will use the first 13 principal components for SCTransform and the first 18 principal components for Seurat VST."
  },
  {
    "objectID": "analysis/01_empty_droplets.html",
    "href": "analysis/01_empty_droplets.html",
    "title": "Empty droplets",
    "section": "",
    "text": "In this document we are going to read in the unfiltered counts matrix produced by Cell Ranger and determine which of those droplets contain cells using the DropletUtils package.\n\n\nCode\nsample_names &lt;- c(\"PVM_0h\", \"PVEU_0h\", \"PVM_4h\", \n                  \"PVEU_4h\", \"PVM_7h\", \"PVEU_7h\")\n\n# Make an sce object of raw barcode counts\n#file_paths &lt;- file.path(\"data/cellranger_results\",sample_names,\"raw_feature_bc_matrix\")\nlist_of_files &lt;- str_c(\"~/Desktop/sterile_inflammation/data/cellranger_results/\",sample_names,\n                   \"/raw_feature_bc_matrix\")\nraw &lt;- read10xCounts(list_of_files, col.names=TRUE)\n\n# Add sample-specific prefixes to the raw SCE object\nsample_prefixes &lt;- rep(sample_names, sapply(list_of_files, function(f) {\n  ncol(read10xCounts(f))\n}))\n\ncolnames(raw) &lt;- paste0(sample_prefixes, \"_\", colnames(raw))\ncolnames(raw) &lt;- gsub(\"_1_\", \"_\", colnames(raw))\n\n# Repeat for filtered SCE object\nlist_of_files &lt;- str_c(\"~/Desktop/sterile_inflammation/data/cellranger_results/\", sample_names,\n                       \"/filtered_feature_bc_matrix\")\n\nfiltered &lt;- read10xCounts(list_of_files, col.names = TRUE)\n\n# Add sample-specific prefixes to the filtered SCE object\nsample_prefixes &lt;- rep(sample_names, sapply(list_of_files, function(f) {\n  ncol(read10xCounts(f))\n}))\n\ncolnames(filtered) &lt;- paste0(sample_prefixes, \"_\", colnames(filtered))\ncolnames(filtered) &lt;- gsub(\"_1_\", \"_\", colnames(filtered))\n\n# Verify the updated barcodes\nhead(colnames(raw))\n\n\n[1] \"PVM_0h_AAACCTGAGAAACCTA-1\" \"PVM_0h_AAACCTGAGAACAACT-1\"\n[3] \"PVM_0h_AAACCTGAGAACTCGG-1\" \"PVM_0h_AAACCTGAGAAGATTC-1\"\n[5] \"PVM_0h_AAACCTGAGAAGCCCA-1\" \"PVM_0h_AAACCTGAGAATTCCC-1\"\n\n\nCode\nhead(colnames(filtered))\n\n\n[1] \"PVM_0h_AAACCTGGTGCTAGCC-1\" \"PVM_0h_AAACCTGTCACATACG-1\"\n[3] \"PVM_0h_AAACCTGTCCTTGGTC-1\" \"PVM_0h_AAACGGGAGACAAGCC-1\"\n[5] \"PVM_0h_AAACGGGAGCCCGAAA-1\" \"PVM_0h_AAACGGGAGCCTATGT-1\"\n\n\nCode\n# Extract barcodes from raw and filtered SCE objects\nraw_barcodes &lt;- colnames(raw)       # Barcodes in the raw SCE\nfiltered_barcodes &lt;- colnames(filtered) # Barcodes in the filtered SCE\n\n# Update CellRangerFilt in the colData of raw\ncolData(raw)$CellRangerFilt &lt;- raw_barcodes %in% filtered_barcodes\n\n# # Verify the result\n# table(colData(raw)$CellRangerFilt)\n# #   FALSE    TRUE \n# # 2029157   39278 \n# \n# nrow(raw)\n# # [1] 32285\n# ncol(raw)\n# # [1] 2068435\n\n\nThe raw object now contains the raw counts and metadata, with an additional column (CellRangerFilt) marking which cells passed Cell Ranger’s initial filtering. The raw dataset has 32285 features and 2068435 droplets at this point.\n\n\nCode\nraw &lt;- raw[Matrix::rowSums(counts(raw)) &gt; 0, Matrix::colSums(counts(raw)) &gt; 0]\n\n\nThe raw object is now pruned to exclude: - Genes that are not expressed in any cell. - Droplets that do not contain any counts (empty droplets).\nAfter removing all zero features and droplets the dataset has 25634 features and 1445128 droplets."
  },
  {
    "objectID": "analysis/01_empty_droplets.html#parameters",
    "href": "analysis/01_empty_droplets.html#parameters",
    "title": "Empty droplets",
    "section": "Parameters",
    "text": "Parameters\nThis table describes parameters used and set in this document.\n\n\nCode\nlibrary(DT)\nparams &lt;- list(\n    list(\n        Parameter = \"n_droplets\",\n        Value = ncol(raw),\n        Description = \"Number of droplets in the raw dataset\"\n    ),\n    list(\n        Parameter = \"empty_thresh\",\n        Value = empty_thresh,\n        Description = \"Droplets with less than this many counts are empty\"\n    ),\n    list(\n        Parameter = \"emp_iters\",\n        Value = emp_iters,\n        Description = \"Number of iterations for EmptyDrops p-values\"\n    ),\n    list(\n        Parameter = \"emp_fdr\",\n        Value = emp_fdr,\n        Description = \"FDR cutoff for EmptyDrops\"\n    ),\n    list(\n        Parameter = \"n_cellranger\",\n        Value = sum(colData(raw)$CellRangerFilt),\n        Description = \"Number of cells selected by the Cell Ranger v3 method\"\n    ),\n    list(\n        Parameter = \"n_empdrops\",\n        Value = sum(colData(raw)$EmpDropsFilt),\n        Description = \"Number of cells selected by the EmptyDrops method\"\n    ),\n    list(\n        Parameter = \"n_cells\",\n        Value = ncol(selected),\n        Description = \"Number of cells selected\"\n    )\n)\n\n# Convert the list to a data frame\nparams_df &lt;- do.call(rbind, lapply(params, as.data.frame))\n\n# Print the datatable without page length or length menu options\ndatatable(\n  params_df,\n  options = list(),\n  rownames = TRUE\n)\n\n\n\n\n\n\nCode\n# json_table &lt;- jsonlite::fromJSON(params)\n# \n# knitr::kable(json_table, format = \"html\") %&gt;%\n#   kable_styling(bootstrap_options = \"striped\", full_width = FALSE, position = \"left\") %&gt;%\n#   scroll_box(width = \"100%\", height = \"400px\")"
  },
  {
    "objectID": "analysis/01_empty_droplets.html#output-files",
    "href": "analysis/01_empty_droplets.html#output-files",
    "title": "Empty droplets",
    "section": "Output files",
    "text": "Output files\nThis table describes the output files produced by this document. Right click and Save Link As… to download the results (to be implemented).\n\n\nCode\nsave(selected, file=here::here(\"output/processed/01_SI_selected.Robj\"))\n\n\n\n\nCode\nreadr::write_lines(params, here::here(\"output/data\", DOCNAME, \"parameters.json\"))\n\n# Assuming all calls return single strings\nfile_links &lt;- c(\n    getDownloadLink(\"01_SI_selected.Robj\", DOCNAME)\n)\n\n# Create data frame\nresults_df &lt;- data.frame(\n    File = file_links,\n    Description = c(\n        \"A SingleCellExperiment object of droplets that were called as cells by either Cell ranger v3 or Empty drops\"\n    ),\n    stringsAsFactors = FALSE  # Optional: Prevent factors if not needed\n)\n\n# Display table using knitr::kable\nknitr::kable(results_df)\n\n\n\n\n\nFile\nDescription\n\n\n\n\n01_SI_selected.Robj\nA SingleCellExperiment object of droplets that were called as cells by either Cell ranger v3 or Empty drops"
  },
  {
    "objectID": "analysis/01_empty_droplets.html#session-information",
    "href": "analysis/01_empty_droplets.html#session-information",
    "title": "Empty droplets",
    "section": "Session information",
    "text": "Session information\n\n\nCode\ndevtools::session_info()\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.3 (2024-02-29)\n os       macOS Sonoma 14.6.1\n system   x86_64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/Vienna\n date     2025-01-04\n pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n ! package              * version   date (UTC) lib source\n P abind                  1.4-8     2024-09-12 [?] CRAN (R 4.3.3)\n   beachmat               2.18.1    2024-02-14 [1] Bioconductor 3.18 (R 4.3.2)\n   Biobase              * 2.62.0    2023-10-24 [1] Bioconductor\n   BiocGenerics         * 0.48.1    2023-11-01 [1] Bioconductor\n P BiocManager            1.30.25   2024-08-28 [?] CRAN (R 4.3.3)\n   BiocParallel           1.36.0    2023-10-24 [1] Bioconductor\n P bit                    4.5.0.1   2024-12-03 [?] RSPM\n P bit64                  4.5.2     2024-09-22 [?] CRAN (R 4.3.3)\n P bitops                 1.0-9     2024-10-03 [?] CRAN (R 4.3.3)\n   bslib                  0.8.0     2024-07-29 [1] RSPM (R 4.3.0)\n P cachem                 1.1.0     2024-05-16 [?] CRAN (R 4.3.3)\n   cli                    3.6.3     2024-06-21 [1] RSPM (R 4.3.0)\n P codetools              0.2-19    2023-02-01 [?] CRAN (R 4.3.3)\n P colorspace             2.1-1     2024-07-26 [?] CRAN (R 4.3.3)\n P cowplot              * 1.1.3     2024-01-22 [?] CRAN (R 4.3.2)\n P crayon                 1.5.3     2024-06-20 [?] CRAN (R 4.3.3)\n P crosstalk              1.2.1     2023-11-23 [?] CRAN (R 4.3.0)\n   DelayedArray           0.28.0    2023-10-24 [1] Bioconductor\n   DelayedMatrixStats     1.24.0    2023-10-24 [1] Bioconductor\n P devtools               2.4.5     2022-10-11 [?] CRAN (R 4.3.0)\n   digest                 0.6.37    2024-08-19 [1] RSPM (R 4.3.0)\n P dplyr                * 1.1.4     2023-11-17 [?] CRAN (R 4.3.0)\n P dqrng                  0.4.1     2024-05-28 [?] RSPM\n   DropletUtils         * 1.22.0    2023-10-24 [1] Bioconductor\n P DT                   * 0.33      2024-04-04 [?] CRAN (R 4.3.2)\n   edgeR                  4.0.16    2024-02-18 [1] Bioconductor 3.18 (R 4.3.2)\n P ellipsis               0.3.2     2021-04-29 [?] CRAN (R 4.3.0)\n   evaluate               1.0.1     2024-10-10 [1] RSPM (R 4.3.0)\n P farver                 2.1.2     2024-05-13 [?] CRAN (R 4.3.3)\n P fastmap                1.2.0     2024-05-15 [?] CRAN (R 4.3.3)\n P forcats              * 1.0.0     2023-01-29 [?] RSPM\n   fs                     1.6.5     2024-10-30 [1] RSPM (R 4.3.0)\n P generics               0.1.3     2022-07-05 [?] CRAN (R 4.3.0)\n   GenomeInfoDb         * 1.38.8    2024-03-15 [1] Bioconductor 3.18 (R 4.3.3)\n   GenomeInfoDbData       1.2.11    2024-12-25 [1] Bioconductor\n   GenomicRanges        * 1.54.1    2023-10-29 [1] Bioconductor\n P ggplot2              * 3.5.1     2024-04-23 [?] CRAN (R 4.3.2)\n P git2r                  0.35.0    2024-10-20 [?] RSPM\n   glue                   1.8.0     2024-09-30 [1] RSPM (R 4.3.0)\n P gridExtra              2.3       2017-09-09 [?] CRAN (R 4.3.0)\n P gtable                 0.3.6     2024-10-25 [?] CRAN (R 4.3.3)\n   HDF5Array              1.30.1    2024-03-06 [1] Bioconductor 3.18 (R 4.3.3)\n P here                 * 1.0.1     2020-12-13 [?] CRAN (R 4.3.0)\n P hms                    1.1.3     2023-03-21 [?] CRAN (R 4.3.0)\n P htmltools              0.5.8.1   2024-04-04 [?] CRAN (R 4.3.2)\n P htmlwidgets            1.6.4     2023-12-06 [?] CRAN (R 4.3.0)\n P httpuv                 1.6.15    2024-03-26 [?] CRAN (R 4.3.2)\n   IRanges              * 2.36.0    2023-10-24 [1] Bioconductor\n P jquerylib              0.1.4     2021-04-26 [?] CRAN (R 4.3.0)\n   jsonlite               1.8.9     2024-09-20 [1] RSPM (R 4.3.0)\n P kableExtra           * 1.4.0     2024-01-24 [?] RSPM\n   knitr                  1.49      2024-11-08 [1] RSPM (R 4.3.0)\n P labeling               0.4.3     2023-08-29 [?] CRAN (R 4.3.0)\n P later                  1.4.1     2024-11-27 [?] RSPM\n P lattice                0.22-5    2023-10-24 [?] CRAN (R 4.3.3)\n P lifecycle              1.0.4     2023-11-07 [?] CRAN (R 4.3.0)\n   limma                  3.58.1    2023-10-31 [1] Bioconductor\n   locfit                 1.5-9.10  2024-06-24 [1] RSPM (R 4.3.0)\n P lubridate            * 1.9.4     2024-12-08 [?] RSPM\n   magrittr               2.0.3     2022-03-30 [1] RSPM (R 4.3.0)\n P Matrix               * 1.6-5     2024-01-11 [?] CRAN (R 4.3.3)\n   MatrixGenerics       * 1.14.0    2023-10-24 [1] Bioconductor\n P matrixStats          * 1.4.1     2024-09-08 [?] CRAN (R 4.3.3)\n P memoise                2.0.1     2021-11-26 [?] CRAN (R 4.3.0)\n P mime                   0.12      2021-09-28 [?] CRAN (R 4.3.0)\n P miniUI                 0.1.1.1   2018-05-18 [?] CRAN (R 4.3.0)\n P munsell                0.5.1     2024-04-01 [?] CRAN (R 4.3.2)\n P pillar                 1.10.0    2024-12-17 [?] RSPM\n P pkgbuild               1.4.5     2024-10-28 [?] CRAN (R 4.3.3)\n P pkgconfig              2.0.3     2019-09-22 [?] CRAN (R 4.3.0)\n P pkgload                1.4.0     2024-06-28 [?] RSPM\n P plyr                   1.8.9     2023-10-02 [?] CRAN (R 4.3.0)\n P profvis                0.4.0     2024-09-20 [?] CRAN (R 4.3.3)\n P promises               1.3.2     2024-11-28 [?] RSPM\n P purrr                * 1.0.2     2023-08-10 [?] CRAN (R 4.3.0)\n   R.methodsS3            1.8.2     2022-06-13 [1] RSPM (R 4.3.0)\n   R.oo                   1.27.0    2024-11-01 [1] RSPM (R 4.3.0)\n   R.utils                2.12.3    2023-11-18 [1] RSPM (R 4.3.0)\n P R6                     2.5.1     2021-08-19 [?] CRAN (R 4.3.0)\n P ragg                   1.3.3     2024-09-11 [?] CRAN (R 4.3.3)\n P Rcpp                   1.0.13-1  2024-11-02 [?] CRAN (R 4.3.3)\n   RCurl                  1.98-1.16 2024-07-11 [1] RSPM (R 4.3.0)\n P readr                * 2.1.5     2024-01-10 [?] RSPM\n P remotes                2.5.0     2024-03-17 [?] RSPM\n   renv                   1.0.11    2024-10-12 [1] RSPM (R 4.3.0)\n   rhdf5                  2.46.1    2023-11-29 [1] Bioconductor\n   rhdf5filters           1.14.1    2023-11-06 [1] Bioconductor\n   Rhdf5lib               1.24.2    2024-02-07 [1] Bioconductor 3.18 (R 4.3.2)\n   rlang                  1.1.4     2024-06-04 [1] RSPM (R 4.3.0)\n   rmarkdown              2.29      2024-11-04 [1] RSPM (R 4.3.0)\n P rprojroot              2.0.4     2023-11-05 [?] CRAN (R 4.3.0)\n P rstudioapi             0.17.1    2024-10-22 [?] CRAN (R 4.3.3)\n   S4Arrays               1.2.1     2024-03-06 [1] Bioconductor 3.18 (R 4.3.3)\n   S4Vectors            * 0.40.2    2023-11-23 [1] Bioconductor\n P sass                   0.4.9     2024-03-15 [?] CRAN (R 4.3.2)\n P scales                 1.3.0     2023-11-28 [?] CRAN (R 4.3.0)\n   scuttle                1.12.0    2023-10-24 [1] Bioconductor\n P sessioninfo            1.2.2     2021-12-06 [?] CRAN (R 4.3.0)\n P shiny                  1.10.0    2024-12-14 [?] RSPM\n   SingleCellExperiment * 1.24.0    2023-10-24 [1] Bioconductor\n   SparseArray            1.2.4     2024-02-11 [1] Bioconductor 3.18 (R 4.3.2)\n   sparseMatrixStats      1.14.0    2023-10-24 [1] Bioconductor\n   statmod                1.5.0     2023-01-06 [1] RSPM (R 4.3.0)\n P stringi                1.8.4     2024-05-06 [?] CRAN (R 4.3.2)\n   stringr              * 1.5.1     2023-11-14 [1] RSPM (R 4.3.0)\n   SummarizedExperiment * 1.32.0    2023-10-24 [1] Bioconductor\n P svglite                2.1.3     2023-12-08 [?] RSPM\n P systemfonts            1.1.0     2024-05-15 [?] RSPM\n P textshaping            0.4.1     2024-12-06 [?] RSPM\n P tibble               * 3.2.1     2023-03-20 [?] CRAN (R 4.3.0)\n P tidyr                * 1.3.1     2024-01-24 [?] CRAN (R 4.3.2)\n P tidyselect             1.2.1     2024-03-11 [?] CRAN (R 4.3.2)\n P tidyverse            * 2.0.0     2023-02-22 [?] CRAN (R 4.3.0)\n P timechange             0.3.0     2024-01-18 [?] CRAN (R 4.3.0)\n P tzdb                   0.4.0     2023-05-12 [?] CRAN (R 4.3.0)\n P UpSetR               * 1.4.0     2019-05-22 [?] CRAN (R 4.3.0)\n P urlchecker             1.0.1     2021-11-30 [?] CRAN (R 4.3.0)\n P usethis                3.1.0     2024-11-26 [?] CRAN (R 4.3.3)\n P vctrs                  0.6.5     2023-12-01 [?] CRAN (R 4.3.0)\n P viridisLite            0.4.2     2023-05-02 [?] CRAN (R 4.3.0)\n P vroom                  1.6.5     2023-12-05 [?] RSPM\n P withr                  3.0.2     2024-10-28 [?] CRAN (R 4.3.3)\n P workflowr              1.7.1     2023-08-23 [?] RSPM\n   xfun                   0.49      2024-10-31 [1] RSPM (R 4.3.0)\n P xml2                   1.3.6     2023-12-04 [?] CRAN (R 4.3.0)\n P xtable                 1.8-4     2019-04-21 [?] CRAN (R 4.3.0)\n   XVector                0.42.0    2023-10-24 [1] Bioconductor\n   yaml                   2.3.10    2024-07-26 [1] RSPM (R 4.3.0)\n   zlibbioc               1.48.2    2024-03-13 [1] Bioconductor 3.18 (R 4.3.3)\n\n [1] /Users/nami/Desktop/sterile_inflammation/renv/library/R-4.3/x86_64-apple-darwin20\n [2] /Users/nami/Library/Caches/org.R-project.R/R/renv/sandbox/R-4.3/x86_64-apple-darwin20/b06620f4\n\n P ── Loaded and on-disk path mismatch.\n\n──────────────────────────────────────────────────────────────────────────────"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "This wesbite displays the analysis code and results for the sterile inflammation project in collaboration with Dr. Shweta Tikoo at the Deaprtment of Dermatology at the MedUni Wien.\nThe project aims to define changes in transcriptional landscape of stromal cells and leukocytes post sterile inflammation. These cells coordinate the recruitment of diverse immune cell subsets from circulation to the inflammed tissue to restrict inflammation and promote tissue repair.\nThe samples consist of FACS sorted cells from murine cremaster tissue under homeostasis or post-TNFa treatment at two different time points. The cells were then sequenced after cDNA libraries preparation.\nThe analysis shown here focuses on the decisions that were made during analysis and demonstrates a range of tools that can be used for various tasks."
  }
]