[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "analysis/about.html",
    "href": "analysis/about.html",
    "title": "About",
    "section": "",
    "text": "Sterile inflammation\nThis repository displays the analysis code and results for the sterile inflammation project in collaboration with Dr. Shweta Tikoo at the Deaprtment of Dermatology at the MedUni Wien.\nThe project aims to define changes in transcriptional landscape of stromal cells and leukocytes post sterile inflammation. These cells coordinate the recruitment of diverse immune cell subsets from circulation to the inflammed tissue to restrict inflammation and promote tissue repair.\nThe samples consist of FACS sorted cells from murine cremaster tissue under homeostasis or post-TNFa treatment at two different time points. The cells were then sequenced after cDNA libraries preparation.\nThe analysis shown here focuses on the decisions that were made during analysis and demonstrates a range of tools that can be used for various tasks.\nTo see the results of the analysis please visit the analysis website. If you wish to reproduce the analysis follow the instructions on the Getting started page.\nThe code in this analysis is covered by the MIT license and the written content on this website is covered by a Creative Commons CC-BY license.\nThe publications mentioned and datasets used are covered by their respective licenses and usage agreements. Please refer to those sources for details."
  },
  {
    "objectID": "analysis/license.html",
    "href": "analysis/license.html",
    "title": "License",
    "section": "",
    "text": "What license are you using for your code? See choosealicense.com for help deciding. It’s a convention to save a file LICENSE in the root of your Git repo that contains the license text.\nWhat license are you using for the written content on your site? It is traditional to choose a Creative Commons license for this type of content.\nHow should others cite your work? It’s a convention to save a file CITATION in the root of your Git repo that contains the citation information."
  },
  {
    "objectID": "analysis/02_quality_control.html",
    "href": "analysis/02_quality_control.html",
    "title": "Quality control",
    "section": "",
    "text": "In this document we are going to explore the dataset and filter it to remove low quality cells and lowly expressed genes. The goal is to have a high quality dataset that can be used for further analysis.\nFirst we will use size factors to normalize raw counts across cells to account for differences in sequencing depth or library size. Library size is the total number of counts (UMIs or reads) observed for a cell. Size factors are calc based on the total counts (library size) for each cell in the dataset. Cells with larger library sizes get higher size factors, and vice versa. Library size factors can differ by up to 10-fold across cells. This is typical of the variability in coverage in scRNA-seq data (see histogram below).\nNormalizing by size factors ensures that comparisons of gene expression across cells are not biased by variations in sequencing depth. We will plot library sizes against normalized counts to ensure that library sizes no longer drive the expression levels.\nWe will then create a Seurat object with the cell barcodes that were found to be not empty droplets from our previous analysis. After normalizing, we will check that the normalized counts vs lib size in the seurat object recapitulate the findings in the SCE object. Once done, we will perform QC and PCA, and calculate tSNE and UMAP embeddings.\n\n\nCode\nload(paste0(proj_dir, \"/output/processed/01_SI_selected.Robj\"))\n\nset.seed(1)\nsizeFactors(selected) &lt;- librarySizeFactors(selected)\n# summary(sizeFactors(selected))\n# summary(colSums(counts(selected)))\n# plot(sizeFactors(selected), colSums(counts(selected)), log = \"xy\",\n#      xlab = \"Size factor\", ylab = \"Library size\",\n#      main = \"Size factors vs library size\")\n# abline(0, 1, col = \"red\")\n\nselected &lt;- logNormCounts(selected)\n#02_SI_selected.Robj---------\nsave(selected, file=here::here(\"output/processed/02_SI_selected.Robj\"))\n\n\n\n\nCode\nload(paste0(proj_dir, \"/output/processed/02_SI_selected.Robj\"))\n\n#Define sample names and file paths\nsample_names &lt;- c(\"PVM_0h\", \"PVEU_0h\", \"PVM_4h\", \"PVEU_4h\", \"PVM_7h\", \"PVEU_7h\")\nfile_paths &lt;- paste0(\"/Users/nami/Desktop/sterile_inflammation/data/cellranger_results/\", sample_names, \"/raw_feature_bc_matrix\")\n\n# Initialize a list to store Seurat objects\nseurat_list &lt;- list()\n\n# Loop through each sample to read data and create Seurat objects\nfor (i in 1:length(sample_names)) {\n  data &lt;- Read10X(data.dir = file_paths[i])\n  sobj &lt;- CreateSeuratObject(counts = data, project = sample_names[i], min.cells = 0, min.features = 0)\n  sobj$sample &lt;- sample_names[i]  # Add sample information\n  seurat_list[[sample_names[i]]] &lt;- sobj\n}\n\n# Add metadata\nfor (sample in sample_names) {\n  sobj &lt;- seurat_list[[sample]]\n  # Extract time point from sample name\n  time_point &lt;- sub(\".*_(\\\\d+h).*\", \"\\\\1\", sample)\n  # Assign condition based on time point\n  condition &lt;- ifelse(time_point == \"0h\", \"Control\", \"Post-TNFa\")\n  sobj$time_point &lt;- time_point\n  sobj$condition &lt;- condition\n  seurat_list[[sample]] &lt;- sobj\n}\n\n# Loop over each sample name in the seurat_list to seperate them\nfor (sample_name in names(seurat_list)) {\n  # Extract the Seurat object from the list\n  sobj &lt;- seurat_list[[sample_name]]\n  \n  # Assign the Seurat object to a variable with the sample name\n  assign(sample_name, sobj)\n}\n\nremove(sobj, data)\n\n# Combine seurat objects\nsobjects &lt;- list(\n  PVM_0h = PVM_0h,\n  PVEU_0h = PVEU_0h,\n  PVM_4h = PVM_4h,\n  PVEU_4h = PVEU_4h,\n  PVM_7h = PVM_7h,\n  PVEU_7h = PVEU_7h\n)\n\n# Ensure the names correspond to sample names\nsample_names &lt;- names(sobjects)\n\n# Append sample name as a prefix to each cell ID\nsobjects &lt;- mapply(function(obj, sample_name) {\n  # Create new cell IDs by concatenating sample name and original cell ID\n  new_cell_ids &lt;- paste0(sample_name, \"_\", colnames(obj))\n  \n  # Assign the new cell IDs to the Seurat object\n  colnames(obj) &lt;- new_cell_ids\n  \n  # Return the modified Seurat object\n  return(obj)\n}, sobjects, names(sobjects), SIMPLIFY = FALSE)\n\n\n# Merge all Seurat objects with sample-specific prefixes\nsobj &lt;- sobjects[[1]]\n\n# Iteratively merge the remaining Seurat objects\nfor (i in 2:length(sobjects)) {\n  sobj &lt;- merge(sobj, y = sobjects[[i]])\n}\n\nsobj &lt;- JoinLayers(sobj)\nsobj\n# An object of class Seurat\n# 20495 features across 44902 samples within 1 assay\n# Active assay: RNA (20495 features, 0 variable features)\n# 1 layer present: counts\n\ntable(sobj$orig.ident)\n# PVEU_0h PVEU_4h PVEU_7h  PVM_0h  PVM_4h  PVM_7h\n# 8642    9076    8841    5800    6853    5690\n\n# Check integrity of obj\n# List the assays present in the Seurat object\nAssays(sobj)\n\n# Check the default assay\nDefaultAssay(sobj)\n\n# Check if the main assay (e.g., RNA) exists and is non-empty\nsobj[[\"RNA\"]]\n\n# Verify the structure of the merged object\nstr(sobj)\n\n# Check the first few cell IDs\nhead(colnames(sobj))\n\n# Extract columns from SCE metadata\nsce_metadata &lt;- data.frame(\n  Sample = colnames(selected),  # Extract cell barcodes\n  CellBarcode = selected@colData@listData[[\"Barcode\"]],\n  CellRangerFilt = selected@colData@listData[[\"CellRangerFilt\"]],\n  EmpDropsFilt = selected@colData@listData[[\"EmpDropsFilt\"]],\n  SelMethod = selected@colData@listData[[\"SelMethod\"]]\n)\n\n# Check the updated CellBarcode values\nhead(sce_metadata$CellBarcode)\n\n# Add prefix to CellBarcode\nsce_metadata$CellBarcode &lt;- paste0(\n  str_extract(sce_metadata$Sample, \"^[^_]*_[^_]*\"), # Extract everything before the 2nd underscore\n  \"_\",\n  sce_metadata$CellBarcode # Append original CellBarcode\n)\nsce_metadata$CellBarcode\n\n# Preview the modified column\nhead(sce_metadata$CellBarcode)\n\n# Subset the Seurat object to include only the common barcodes\ncommon_barcodes &lt;- sce_metadata$CellBarcode\nsobj &lt;- subset(sobj, cells = common_barcodes)\ndim(sobj)  \n\n# Add metadata to Seurat object\n# Ensure matching by CellBarcode\nrownames(sce_metadata) &lt;- sce_metadata$CellBarcode\nsobj &lt;- AddMetaData(sobj, metadata = sce_metadata)\n\n# Calculate percentage of mitochondrial genes\nsobj[[\"percent.mt\"]] &lt;- PercentageFeatureSet(object = sobj, pattern = \"^mt-\")\n\n# Add number of genes per UMI for each cell to metadata\nsobj$log10genes_per_UMI &lt;- log10(sobj$nFeature_RNA) / log10(sobj$nCount_RNA)\n\nsobj@meta.data &lt;- sobj@meta.data %&gt;%\n  select(-Sample, -CellBarcode)\n\n# Modify the \"sample\" column in the meta.data slot\nsobj@meta.data[[\"sample\"]] &lt;- gsub(\"_.*$\", \"\", sobj@meta.data[[\"sample\"]])\n\n# Verify the changes\nhead(sobj@meta.data[[\"sample\"]])\n\n#02_SI_sobj.Robj---------\nsave(sobj, file=\"/home/nsingh/sterile_inflammation/output/processed/02_SI_sobj.Robj\")\n\n# Normalize and scale\nsobj &lt;- NormalizeData(\n  object = sobj,\n  normalization.method = \"LogNormalize\", # Log-normalization\n  scale.factor = 10000                   # Scaling factor\n)\nsobj &lt;- ScaleData(sobj)\n#02_SI_sobj_scale.Robj---------\nsave(sobj, file=\"/home/nsingh/sterile_inflammation/output/processed/02_SI_sobj_scale.Robj\")\n\n\n\n\n\nSCESeurat\n\n\n\n\n\n\n\n\nCode\nload(paste0(proj_dir, \"/output/processed/02_SI_sobj_scale.Robj\"))\n# Extract library sizes\nlibrary_sizes &lt;- colSums(sobj@assays$RNA$counts)\n\n# Extract normalized data means\nmean_logcounts &lt;- Matrix::colMeans(sobj@assays$RNA$data)\n\n# Plot size factors vs library sizes\nplot(log10(library_sizes), mean_logcounts,\n     xlab = \"Log10 library size\",\n     ylab = \"Mean log-normalized counts\",\n     main = \"Normalized counts vs library size\")\nabline(h = median(mean_logcounts), col = \"red\", lty = 2)"
  },
  {
    "objectID": "analysis/02_quality_control.html#check-lib-size-vs-normalization",
    "href": "analysis/02_quality_control.html#check-lib-size-vs-normalization",
    "title": "Quality control",
    "section": "",
    "text": "SCESeurat\n\n\n\n\n\n\n\n\nCode\nload(paste0(proj_dir, \"/output/processed/02_SI_sobj_scale.Robj\"))\n# Extract library sizes\nlibrary_sizes &lt;- colSums(sobj@assays$RNA$counts)\n\n# Extract normalized data means\nmean_logcounts &lt;- Matrix::colMeans(sobj@assays$RNA$data)\n\n# Plot size factors vs library sizes\nplot(log10(library_sizes), mean_logcounts,\n     xlab = \"Log10 library size\",\n     ylab = \"Mean log-normalized counts\",\n     main = \"Normalized counts vs library size\")\nabline(h = median(mean_logcounts), col = \"red\", lty = 2)"
  },
  {
    "objectID": "analysis/02_quality_control.html#expression-by-cell---mads",
    "href": "analysis/02_quality_control.html#expression-by-cell---mads",
    "title": "Quality control",
    "section": "Expression by cell - MADs",
    "text": "Expression by cell - MADs\nDistributions by cell. Blue line shows the median and red lines show median absolute deviations (MADs) from the median.\n\nTotal countsTotal featuresPercent mitochondrial\n\n\n\n\nCode\nload(paste0(proj_dir, \"/output/processed/02_SI_sobj_scale.Robj\"))\noutlierHistogramSeurat(sobj, feature=\"nCount_RNA\", mads = 1:6)\n\n\n\n\n\n\n\nCode\noutlierHistogramSeurat(sobj, feature=\"nFeature_RNA\", mads = 1:6)\n\n\n\n\n\n\n\nCode\noutlierHistogramSeurat(sobj, feature=\"percent.mt\", mads = 1:6)"
  },
  {
    "objectID": "analysis/02_quality_control.html#expression-by-cell---manual",
    "href": "analysis/02_quality_control.html#expression-by-cell---manual",
    "title": "Quality control",
    "section": "Expression by cell - manual",
    "text": "Expression by cell - manual\n\nnCount_RNAnFeature_RNAPercent mitochondrialLog10 genes per UMI\n\n\n\n\nCode\np1 &lt;- VlnPlot(sobj, \n              features = c(\"nCount_RNA\"), \n              ncol = 1, \n              assay = \"RNA\", \n              group.by = \"orig.ident\",\n              cols = sample_colors, \n              stack = FALSE) & geom_hline(yintercept =500, col=\"blue\") \n              annotate(\"text\", x=0.5, y=1000, label=\"      500\", size=2,color = \"blue\")\n\n# Visualize the number UMIs/transcripts per cell\n# UMI count should be above 500 low-end, expected\n# between 500-1000 counts, usable should have been sequenced more deeply\np2 &lt;- sobj@meta.data %&gt;% \n  ggplot(aes(color=orig.ident, x=nCount_RNA, fill= orig.ident)) + \n  geom_density(alpha = 0.2) + \n  scale_x_log10() + \n  theme_classic() +\n  ylab(\"Cell density\") +\n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) + \n  geom_vline(xintercept = 500)\n  NoLegend()\n\n# FeatureScatter plot for nCount_RNA vs nFeature_RNA\n# Generate the FeatureScatter plot as a ggplot object\np3 &lt;- FeatureScatter(\n    object = sobj, \n    group.by = \"orig.ident\",\n    split.by = NULL,\n    feature1 = \"nCount_RNA\", \n    cols = sample_colors,\n    feature2 = \"nFeature_RNA\", \n    shuffle = TRUE, \n    plot.cor = FALSE\n)\n\np3 &lt;- p3 + \n    geom_vline(xintercept = 500, color = \"blue\", linetype = \"dashed\") + \n    geom_hline(yintercept = 300, color = \"blue\", linetype = \"dashed\") + \n    annotate(\"text\", x = 500, y = 4000, \n             label = \"500\", color = \"blue\", vjust = -0.5, hjust = -0.1, angle = 90) +\n    annotate(\"text\", x = 30000, y = 300, \n             label = \"300\", color = \"blue\", vjust = -0.5, hjust = -0.1)\n\n# FeatureScatter plot for nCount_RNA vs percent.mt\np4 &lt;- FeatureScatter(\n    object = sobj, \n    group.by = \"orig.ident\",\n    split.by = NULL,\n    feature1 = \"nCount_RNA\", \n    cols = sample_colors,\n    feature2 = \"percent.mt\", \n    shuffle = TRUE, \n    plot.cor = FALSE\n)  \n\np4 &lt;- p4 + \n    geom_vline(xintercept = 500, color = \"blue\", linetype = \"dashed\") + \n    geom_hline(yintercept = 5, color = \"red\", linetype = \"dashed\") + \n    annotate(\"text\", x = 500, y = 75, \n             label = \"500\", color = \"blue\", vjust = -0.5, hjust = -0.1, angle = 90) +\n    annotate(\"text\", x = 30000, y = 5, \n             label = \"5%\", color = \"red\", vjust = -0.5, hjust = -0.1)\n\n# Visualize the correlation between genes detected and number of UMIs and determine whether strong presence of cells with low numbers of genes/UMIs\n# poor quality cells likely to have low genes & UMIs per cell\np5 &lt;- sobj@meta.data %&gt;% \n  ggplot(aes(x=nCount_RNA, y=nFeature_RNA, color=percent.mt)) + \n  geom_point() + \n  scale_colour_gradient(low = \"gray90\", high = \"black\") +\n  stat_smooth(method=lm) +\n  scale_x_log10() + \n  scale_y_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 500) +\n  geom_hline(yintercept = 250) +\n  facet_wrap(~orig.ident)\n\np &lt;- p1 + p2 + p3 + p4 + p5 + plot_layout(\n    ncol = 2, guides = \"collect\") + plot_annotation(\n        title = \"Before filtering\", \n        tag_levels = \"A\")\np\n\n\n\n\n\n\n\nCode\np1 &lt;- VlnPlot(sobj, \n              features = c(\"nFeature_RNA\"), \n              ncol = 1, assay = \"RNA\", \n              group.by = \"orig.ident\", \n              cols = sample_colors, \n              stack = FALSE) & geom_hline(yintercept =300, col=\"blue\") & #geom_hline(yintercept = 3500, col=\"red\") & \n              annotate(\"text\", x=0.5, y=400, label=\"    300\", size=2,color = \"blue\") #& \n              #annotate(\"text\", x=0.5, y=3600, label=\"    3500\", size=2,color = \"red\") \n# Visualize the distribution of genes detected per cell via histogram\n# single peak represents cells encapsulated\n# shoulder/bimodal distribution: 1.cells that failed, 2. biologically different types (quiescent cells, less complex cells,size)\np2 &lt;- sobj@meta.data %&gt;% \n  ggplot(aes(color=orig.ident, x=nFeature_RNA, fill= orig.ident)) + \n  geom_density(alpha = 0.2) + \n  theme_classic() +\n  scale_x_log10() + \n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) + #geom_vline(xintercept = 3500) +\n  geom_vline(xintercept = 300) & NoLegend()#cutoff at &gt;400 ?\n\np3 &lt;- FeatureScatter(object = sobj, \n                        group.by = \"orig.ident\",\n                        split.by = NULL,\n                        feature1 = \"nCount_RNA\", \n                        cols = sample_colors,\n                        feature2 = \"nFeature_RNA\", \n        shuffle = TRUE, plot.cor = FALSE)  & NoLegend()\np3 &lt;- p3 + \n    geom_vline(xintercept = 500, color = \"blue\", linetype = \"dashed\") + \n    geom_hline(yintercept = 300, color = \"blue\", linetype = \"dashed\") + \n    annotate(\"text\", x = 500, y = 4000, \n             label = \"500\", color = \"blue\", vjust = -0.5, hjust = -0.1, angle = 90) +\n    annotate(\"text\", x = 30000, y = 300, \n             label = \"300\", color = \"blue\", vjust = -0.5, hjust = -0.1)\n\np4 &lt;- FeatureScatter(object = sobj, \n                        group.by = \"orig.ident\",\n                        split.by = NULL,\n                        feature1 = \"nFeature_RNA\", \n                        cols = sample_colors,\n                        feature2 = \"percent.mt\", \n        shuffle = TRUE, plot.cor = FALSE)  & NoLegend()\np4 &lt;- p4 + \n    geom_vline(xintercept = 300, color = \"blue\", linetype = \"dashed\") + \n    geom_hline(yintercept = 5, color = \"red\", linetype = \"dashed\") + \n    annotate(\"text\", x = 300, y = 75, \n             label = \"300\", color = \"blue\", vjust = -0.5, hjust = -0.1, angle = 90) +\n    annotate(\"text\", x = 30000, y = 5, \n             label = \"5%\", color = \"red\", vjust = -0.5, hjust = -0.1)\n\n# Visualize the correlation between genes detected and number of UMIs and determine whether strong presence of cells with low numbers of genes/UMIs\n# poor quality cells likely to have low genes & UMIs per cell\np5 &lt;- sobj@meta.data %&gt;% \n  ggplot(aes(x=nCount_RNA, y=nFeature_RNA, color=percent.mt)) + \n  geom_point() + \n  scale_colour_gradient(low = \"gray90\", high = \"black\") +\n  stat_smooth(method=lm) +\n  scale_x_log10() + \n  scale_y_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 500) +\n  geom_hline(yintercept = 250) +\n  facet_wrap(~orig.ident)\n\np &lt;- p1 + p2 + p3 + p4 + p5 + plot_layout(\n    ncol = 2, guides = \"collect\") + plot_annotation(\n        title = \"Before filtering\", \n        tag_levels = \"A\")\np\n\n\n\n\n\n\n\nCode\n# Visualize the distribution of mitochondrial gene expression detected per cell\n# indication if there's large amount of mito-contamination f. dead/dying cells, above 0.2 mito ratio mark poor quality, unless expected differently \np1 &lt;- VlnPlot(sobj, \n              features = c(\"percent.mt\"), \n              ncol = 1, \n              assay = \"RNA\", \n              group.by = \"orig.ident\", \n              cols = sample_colors, \n              stack = FALSE) & geom_hline(yintercept = 10, col=\"red\")& \n              annotate(\"text\", x=0.5, y=13, label=\"     5%\", size=3,color = \"red\") \n\np2 &lt;-sobj@meta.data %&gt;%\n  ggplot(aes(color=orig.ident, x=percent.mt, fill=orig.ident)) + \n  geom_density(alpha = 0.2) + \n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) +\n  scale_x_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 5) & NoLegend()\n\n# FeatureScatter plot for nCount_RNA vs percent.mt\np3 &lt;- FeatureScatter(\n    object = sobj, \n    group.by = \"orig.ident\",\n    split.by = NULL,\n    feature1 = \"nCount_RNA\", \n    cols = sample_colors,\n    feature2 = \"percent.mt\", \n    shuffle = TRUE, \n    plot.cor = FALSE\n)  \n\np3 &lt;- p3 + \n    geom_vline(xintercept = 500, color = \"blue\", linetype = \"dashed\") + \n    geom_hline(yintercept = 5, color = \"red\", linetype = \"dashed\") + \n    annotate(\"text\", x = 500, y = 75, \n             label = \"500\", color = \"blue\", vjust = -0.5, hjust = -0.1, angle = 90) +\n    annotate(\"text\", x = 30000, y = 5, \n             label = \"5%\", color = \"red\", vjust = -0.5, hjust = -0.1)\n\np4 &lt;- FeatureScatter(object = sobj, \n                        group.by = \"orig.ident\",\n                        split.by = NULL,\n                        feature1 = \"nFeature_RNA\", \n                        cols = sample_colors,\n                        feature2 = \"percent.mt\", \n        shuffle = TRUE, plot.cor = FALSE)  & NoLegend()\np4 &lt;- p4 + \n    geom_vline(xintercept = 300, color = \"blue\", linetype = \"dashed\") + \n    geom_hline(yintercept = 5, color = \"red\", linetype = \"dashed\") + \n    annotate(\"text\", x = 300, y = 75, \n             label = \"300\", color = \"blue\", vjust = -0.5, hjust = -0.1, angle = 90) +\n    annotate(\"text\", x = 30000, y = 5, \n             label = \"5%\", color = \"red\", vjust = -0.5, hjust = -0.1)\n\np &lt;- p1 + p2 + p3 + p4 + plot_layout(\n    ncol = 2, guides = \"collect\") + plot_annotation(\n        title = \"Before filtering\", \n        tag_levels = \"A\")\np\n\n\n\n\n\n\n\nCode\np1 &lt;- VlnPlot(sobj, \n              features = c(\"log10genes_per_UMI\"), \n              ncol = 1, \n              assay = \"RNA\", \n              group.by = \"orig.ident\", \n              cols = sample_colors, \n              stack = FALSE) & geom_hline(yintercept = 0.8, col=\"blue\") & \n              annotate(\"text\", x=0.7, y=0.81, label=\"0.8\", size=3,color = \"blue\")  \n\n# Visualize the overall complexity of the gene expression by visualizing the genes detected per UMI\n# novelty score: ratio Genes/UMI\n# highUMI & low Genes = only little genes, sequences over again == low complexity/novelty; associated to cell type? or  artifact?\n# above 0.8\np2 &lt;- sobj@meta.data %&gt;%\n  ggplot(aes(x=log10genes_per_UMI, color = orig.ident, fill=orig.ident)) +\n  geom_density(alpha = 0.2) +\n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) +\n  theme_classic() +\n  geom_vline(xintercept = 0.8) & NoLegend()\n\np &lt;- p1 + p2 + plot_layout(\n    ncol = 2, guides = \"collect\") + plot_annotation(\n        title = \"Before filtering\", \n        tag_levels = \"A\")\np\nrm(sobj)"
  },
  {
    "objectID": "analysis/02_quality_control.html#post-filtering-1-qc-metrics",
    "href": "analysis/02_quality_control.html#post-filtering-1-qc-metrics",
    "title": "Quality control",
    "section": "Post filtering #1 QC metrics",
    "text": "Post filtering #1 QC metrics\n\n\nCode\nload(paste0(proj_dir, \"/output/processed/02_SI_sobj_qc.Robj\"))\np1 &lt;- VlnPlot(filtered_sobj, \n              features = c(\"nFeature_RNA\"), \n              ncol = 1, assay = \"RNA\", \n              group.by = \"orig.ident\", \n              cols = sample_colors, \n              stack = FALSE) \np2 &lt;- VlnPlot(filtered_sobj, \n              features = c(\"nCount_RNA\"), \n              ncol = 1, \n              assay = \"RNA\", \n              group.by = \"orig.ident\",\n              cols = sample_colors, \n              stack = FALSE)  \np3 &lt;- VlnPlot(filtered_sobj, \n              features = c(\"percent.mt\"),\n             ncol = 1, \n              assay = \"RNA\", \n              group.by = \"orig.ident\", \n              cols = sample_colors, \n              stack = FALSE) \n\np4 &lt;- VlnPlot(filtered_sobj, \n              features = c(\"log10genes_per_UMI\"), \n              ncol = 1, \n              assay = \"RNA\", \n              group.by = \"orig.ident\", \n              cols = sample_colors, \n              stack = FALSE) \n\n# Visualize the distribution of genes detected per cell via histogram\n  # single peak represents cells encapsulated\n  # shoulder/bimodal distribution: 1.cells that failed, 2. biologically different types (quiescent cells, less complex cells,size)\np5 &lt;- filtered_sobj@meta.data  %&gt;% \n  ggplot(aes(color=orig.ident, x=nFeature_RNA, fill= orig.ident)) + \n  geom_density(alpha = 0.2) + \n  theme_classic() +\n  scale_x_log10() + \n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) + geom_vline(xintercept = 4000) +\n  geom_vline(xintercept = 300) & NoLegend()\n\n\n# Visualize the number UMIs/transcripts per cell\n  # UMI count should be above 500 low-end, expected\n  # between 500-1000 counts, usable should have been sequenced more deeply\np6 &lt;- filtered_sobj@meta.data %&gt;% \n  ggplot(aes(color=orig.ident, x=nCount_RNA, fill= orig.ident)) + \n  geom_density(alpha = 0.2) + \n  scale_x_log10() + \n  theme_classic() +\n  ylab(\"Cell density\") +\n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) + geom_vline(xintercept = 500) + \n  geom_vline(xintercept = 20000) + \n  NoLegend()\n\n# Visualize the distribution of mitochondrial gene expression detected per cell\n  # indication if there's large amount of mito-contamination f. dead/dying cells, above 0.2 mito ratio mark poor quality, unless expected differently \n\np7 &lt;- filtered_sobj@meta.data %&gt;%\n  ggplot(aes(color=orig.ident, x=percent.mt, fill=orig.ident)) + \n  geom_density(alpha = 0.2) + \n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) +\n  scale_x_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 5) & NoLegend()\n\n\n# Visualize the overall complexity of the gene expression by visualizing the genes detected per UMI\n  # novelty score: ratio Genes/UMI\n  # highUMI & low Genes = only little genes, sequences over again == low complexity/novelty; associated to cell type? or  artifact?\n  # above 0.8\np8 &lt;- filtered_sobj@meta.data %&gt;%\n  ggplot(aes(x=log10genes_per_UMI, color = orig.ident, fill=orig.ident)) +\n  geom_density(alpha = 0.2) +\n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) +\n  theme_classic() +\n  geom_vline(xintercept = 0.8) & NoLegend()\n\n\np &lt;- p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8 + plot_layout(\n    ncol = 4, guides = \"collect\") + plot_annotation(\n        title = \"After filtering\", \n        tag_levels = \"A\")\np\nrm(filtered_sobj)\n\n\n\nWe have removed some extreme outliers but QC is always an iterative process, so we will look at some more factors to ensure only quality cells remain. We will also fine tune QC to set some sample-specific thresholds.\nCells with high nCount_RNA and nFeature_RNA are retained for now as they help in simulating doublets.\nWe will check for doublets next."
  },
  {
    "objectID": "analysis/02_quality_control.html#post-filtering-2-qc-metrics",
    "href": "analysis/02_quality_control.html#post-filtering-2-qc-metrics",
    "title": "Quality control",
    "section": "Post filtering #2 QC metrics",
    "text": "Post filtering #2 QC metrics\n\n\nCode\nload(paste0(proj_dir, \"/output/processed/02_SI_sobj_post_df.Robj\"))\np1 &lt;- VlnPlot(sobj_post_df, \n              features = c(\"nFeature_RNA\"), \n              ncol = 1, assay = \"RNA\", \n              group.by = \"orig.ident\", \n              cols = sample_colors, \n              stack = FALSE) \np2 &lt;- VlnPlot(sobj_post_df, \n              features = c(\"nCount_RNA\"), \n              ncol = 1, \n              assay = \"RNA\", \n              group.by = \"orig.ident\",\n              cols = sample_colors, \n              stack = FALSE)  \np3 &lt;- VlnPlot(sobj_post_df, \n              features = c(\"percent.mt\"),\n             ncol = 1, \n              assay = \"RNA\", \n              group.by = \"orig.ident\", \n              cols = sample_colors, \n              stack = FALSE) \n\np4 &lt;- VlnPlot(sobj_post_df, \n              features = c(\"log10genes_per_UMI\"), \n              ncol = 1, \n              assay = \"RNA\", \n              group.by = \"orig.ident\", \n              cols = sample_colors, \n              stack = FALSE) \n\n# Visualize the distribution of genes detected per cell via histogram\n  # single peak represents cells encapsulated\n  # shoulder/bimodal distribution: 1.cells that failed, 2. biologically different types (quiescent cells, less complex cells,size)\np5 &lt;- sobj_post_df@meta.data  %&gt;% \n  ggplot(aes(color=orig.ident, x=nFeature_RNA, fill= orig.ident)) + \n  geom_density(alpha = 0.2) + \n  theme_classic() +\n  scale_x_log10() + \n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) + geom_vline(xintercept = 4000) +\n  geom_vline(xintercept = 300) & NoLegend()\n\n\n# Visualize the number UMIs/transcripts per cell\n  # UMI count should be above 500 low-end, expected\n  # between 500-1000 counts, usable should have been sequenced more deeply\np6 &lt;- sobj_post_df@meta.data %&gt;% \n  ggplot(aes(color=orig.ident, x=nCount_RNA, fill= orig.ident)) + \n  geom_density(alpha = 0.2) + \n  scale_x_log10() + \n  theme_classic() +\n  ylab(\"Cell density\") +\n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) + geom_vline(xintercept = 500) + \n  geom_vline(xintercept = 20000) + \n  NoLegend()\n\n# Visualize the distribution of mitochondrial gene expression detected per cell\n  # indication if there's large amount of mito-contamination f. dead/dying cells, above 0.2 mito ratio mark poor quality, unless expected differently \n\np7 &lt;- sobj_post_df@meta.data %&gt;%\n  ggplot(aes(color=orig.ident, x=percent.mt, fill=orig.ident)) + \n  geom_density(alpha = 0.2) + \n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) +\n  scale_x_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 5) & NoLegend()\n\n\n# Visualize the overall complexity of the gene expression by visualizing the genes detected per UMI\n  # novelty score: ratio Genes/UMI\n  # highUMI & low Genes = only little genes, sequences over again == low complexity/novelty; associated to cell type? or  artifact?\n  # above 0.8\np8 &lt;- sobj_post_df@meta.data %&gt;%\n  ggplot(aes(x=log10genes_per_UMI, color = orig.ident, fill=orig.ident)) +\n  geom_density(alpha = 0.2) +\n  scale_color_manual(values = sample_colors) +\n  scale_fill_manual(values = sample_colors) +\n  theme_classic() +\n  geom_vline(xintercept = 0.8) & NoLegend()\n\n# FeatureScatter plot for nCount_RNA vs nFeature_RNA\n# Generate the FeatureScatter plot as a ggplot object\np9 &lt;- FeatureScatter(\n    object = sobj_post_df, \n    group.by = \"orig.ident\",\n    split.by = NULL,\n    feature1 = \"nCount_RNA\", \n    cols = sample_colors,\n    feature2 = \"nFeature_RNA\", \n    shuffle = TRUE, \n    plot.cor = FALSE\n)\n\np9 &lt;- p9 + \n    geom_vline(xintercept = 500, color = \"blue\", linetype = \"dashed\") + \n    geom_vline(xintercept = 20000, color = \"red\", linetype = \"dashed\") + \n    geom_hline(yintercept = 300, color = \"blue\", linetype = \"dashed\") + \n    geom_hline(yintercept = 4000, color = \"red\", linetype = \"dashed\") + \n    annotate(\"text\", x = 500, y = 3500, \n             label = \"500\", color = \"blue\", vjust = -0.5, hjust = -0.1, angle = 90) +\n  annotate(\"text\", x = 20000, y = 2500, \n             label = \"20000\", color = \"red\", vjust = -0.5, hjust = -0.1, angle = 90) +\n    annotate(\"text\", x = 19000, y = 300, \n             label = \"300\", color = \"blue\", vjust = -0.5, hjust = -0.1) +\n  annotate(\"text\", x = 500, y = 3700, \n             label = \"4000\", color = \"red\", vjust = -0.5, hjust = -0.1) \n\n# FeatureScatter plot for nCount_RNA vs percent.mt\np10 &lt;- FeatureScatter(\n    object = sobj_post_df, \n    group.by = \"orig.ident\",\n    split.by = NULL,\n    feature1 = \"nFeature_RNA\", \n    cols = sample_colors,\n    feature2 = \"percent.mt\", \n    shuffle = TRUE, \n    plot.cor = FALSE\n)  \n\np10 &lt;- p10 + \n    geom_vline(xintercept = 300, color = \"blue\", linetype = \"dashed\") + \n    geom_vline(xintercept = 4000, color = \"red\", linetype = \"dashed\") + \n    geom_hline(yintercept = 5, color = \"red\", linetype = \"dashed\") + \n    annotate(\"text\", x = 300, y = 4, \n             label = \"300\", color = \"blue\", vjust = -0.5, hjust = -0.1, angle = 90) +\n    annotate(\"text\", x = 4000, y = 4.9, \n             label = \"5%\", color = \"red\", vjust = -0.5, hjust = -0.1) +\n    annotate(\"text\", x = 4000, y = 4, \n             label = \"4000\", color = \"red\", vjust = -0.5, hjust = -0.1, angle = 90)\n\np &lt;- p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8 + plot_layout(\n    ncol = 4, guides = \"collect\") + plot_annotation(\n        title = \"After filtering\", \n        tag_levels = \"A\")\np\n\np &lt;- p9 + p10 + plot_layout(\n    ncol = 2, guides = \"collect\") + plot_annotation(\n        title = \"After filtering\", \n        tag_levels = \"A\")\np"
  },
  {
    "objectID": "analysis/02_quality_control.html#gene-expression",
    "href": "analysis/02_quality_control.html#gene-expression",
    "title": "Quality control",
    "section": "Gene expression",
    "text": "Gene expression\nThe relationship between the number of cells that express a gene and the overall expression level can be interesting. We expect to see that higher expressed genes are expressed in more cells but there may be some that stand out from this. Since we already filtered out genes that were expressed in less than 5 cells, we dont expect outliers in that direction.\n\n\nCode\n# Get raw or normalized expression data\nexpr_data &lt;- GetAssayData(sobj_post_df, slot = \"data\")  # Log-normalized counts\n\n# Calculate percentage of cells expressing each gene\npct_cells_expressing &lt;- rowSums(expr_data &gt; 0) / ncol(expr_data) * 100  # Percentage\n\n# Calculate mean expression for each gene\nmean_expression &lt;- rowMeans(expr_data)\n\n# Combine into a data frame\ngene_stats &lt;- data.frame(\n  Gene = rownames(expr_data),\n  PctCellsExpressing = pct_cells_expressing,\n  MeanExpression = mean_expression\n)\n\n# Count genes expressed in at least 50% and 25% of cells\ngenes_50 &lt;- sum(gene_stats$PctCellsExpressing &gt;= 50)\ngenes_25 &lt;- sum(gene_stats$PctCellsExpressing &gt;= 25)\n\n# Create the plot with axes switched\np_gene_exp &lt;- ggplot(gene_stats, aes(x = PctCellsExpressing, y = MeanExpression)) +\n  geom_point(alpha = 0.6) +  # Scatter points\n  geom_smooth(color = \"red\", se = TRUE) +  # Trend line\n  geom_vline(xintercept = 50, linetype = \"dashed\", color = \"blue\") +  \n  annotate(\"text\", x = 47, y = 3,\n           label = paste0(genes_50, \" genes ≥ 50%\"), hjust = 0, angle = 90) +\n  geom_vline(xintercept = 25, linetype = \"dashed\", color = \"blue\") +  \n  annotate(\"text\", x = 22, y = 3, \n           label = paste0(genes_25, \" genes ≥ 25%\"), hjust = 0, angle = 90) +\n  scale_x_continuous(name = \"Percentage of cells expressing\", limits = c(0, 100)) +\n  scale_y_continuous(name = \"Mean expression\") +\n  theme_minimal()\np_gene_exp\n#The outlier gene expressed in 100% cells and mean exp 5 is Gm42418"
  },
  {
    "objectID": "analysis/02_quality_control.html#gene-variance",
    "href": "analysis/02_quality_control.html#gene-variance",
    "title": "Quality control",
    "section": "Gene variance",
    "text": "Gene variance\nThis plot shows the percentage of variance in the dataset that is explained by various technical factors. I am using the variancePartition package which is designed to estimate the contribution of different factors to the variance of each gene’s expression across the dataset to quantify how much each factor (e.g., sample, technical effects) contributes to the total variation in gene expression.\nFor each gene in the dataset, it fits a linear mixed model (LMM) where the expression of the gene is modeled as a function of multiple explanatory variables (factors). The output is the percentage of variance in the gene’s expression that can be attributed to each factor, in other words, the proportion of variance explained by each factor per gene.\nThis is another way of validating our gene filtering. If the variance in a lot of genes is explained by technical factors, then we have to reconsider our filters.\n\n\nCode\nload(paste0(proj_dir, \"/output/processed/02_SI_variancePartition.Robj\"))\n# Figure 1a\n# Bar plot of variance fractions for the first 10 genes\n# plotPercentBars(vp[1:10, ])\n\n# Variance explained by different technical factors\nplotVarPart(vp)\n\n# # Calculate variance explained by sample (categorical)\n# form &lt;- ~ (1 | sample) + (1 | SelMethod) \n# varPart_cat &lt;- fitExtractVarPartModel(expr_data, form, meta_data)\n# \n# # sort variables (i.e. columns) by median fraction\n# #       of variance explained\n# vp &lt;- sortCols(varPart)\n# \n# # Figure 1a\n# # Bar plot of variance fractions for the first 10 genes\n# # plotPercentBars(vp[1:10, ])\n# \n# plotVarPart(vp)\n\n\n\nSince most of the variance in gene expression in the dataset is explained by residuals, this means that we did not introduce any bias."
  },
  {
    "objectID": "analysis/02_quality_control.html#pca-outliers",
    "href": "analysis/02_quality_control.html#pca-outliers",
    "title": "Quality control",
    "section": "PCA outliers",
    "text": "PCA outliers\nAnother approach to validate our filters is to perform a PCA using technical factors instead of gene expression and then use outlier detection to identify low-quality cells.\n\n\nCode\nload(paste0(proj_dir, \"/output/processed/02_SI_sobj_post_df.Robj\"))\n# Define technical factors\ntechnical_factors &lt;- c(\"nCount_RNA\", \"nFeature_RNA\")\n\n# Subset metadata for PCA\nmeta_data_pca &lt;- sobj_post_df@meta.data[, technical_factors]\n\n# Perform PCA using prcomp\npca_result &lt;- prcomp(meta_data_pca, scale. = TRUE)\nsummary(pca_result)  \n\n# Add PCA embeddings to the metadata\npca_embeddings &lt;- as.data.frame(pca_result$x)\ncolnames(pca_embeddings) &lt;- paste0(\"PC_\", 1:ncol(pca_embeddings))\nsobj_post_df@meta.data &lt;- cbind(sobj_post_df@meta.data, pca_embeddings)\n\n# Calculate Z-scores for the first principal component\nsobj_post_df@meta.data$outlier_nCountRNA &lt;- abs(scale(sobj_post_df@meta.data$PC_1)) &gt; 3  # Threshold: Z &gt; 3\n\n# Calculate Z-scores for the second principal component\nsobj_post_df@meta.data$outlier_nFeatureRNA &lt;- abs(scale(sobj_post_df@meta.data$PC_2)) &gt; 4  # Threshold: Z &gt; 4\n\n# Create a new column indicating whether the sample is an outlier in either condition\nsobj_post_df@meta.data$outlier &lt;- sobj_post_df@meta.data$outlier_nCountRNA | sobj_post_df@meta.data$outlier_nFeatureRNA\n\n# Scatter plot of PCA results\nggplot(sobj_post_df@meta.data, aes(x = PC_1, y = PC_2, color = outlier)) +\n  geom_point(alpha = 0.6) +\n  theme_minimal() +\n  scale_color_manual(values = c(\"FALSE\" = \"grey\", \"TRUE\" = \"red\")) +\n  labs(x = \"PC 1\", y = \"PC 2\", color = \"Outlier\")\n\ntable(sobj_post_df@meta.data$outlier)\n\n\n\nSince we don’t see any egregious outliers, our filtering did not introduce any bias."
  },
  {
    "objectID": "analysis/02_quality_control.html#kept-vs-lost",
    "href": "analysis/02_quality_control.html#kept-vs-lost",
    "title": "Quality control",
    "section": "Kept vs Lost",
    "text": "Kept vs Lost\nOne more thing we can look at is the expression level of genes between kept and removed cells. If we see known genes that are highly expressed in the removed cells that can indicate that we have removed an interesting population of cells from the dataset. The red line shows equal expression and the blue line is a linear fit.\n\nX-Axis (LostCapped): Log average gene expression in removed cells.\nY-Axis (KeptCapped): Log average gene expression in kept cells.\nColor (LostProp - KeptProp): Difference in proportion of cells expressing each gene between removed and kept populations. Positive values indicate a gene is more frequently expressed in the removed cells and vice versa. Since most genes are negative, it means they are more prevalent in kept cells!\nRed Line: LostCapped = KeptCapped, indicating genes expressed equally in both removed and kept cells. Genes significantly above red line are more expressed in the kept cells and vice versa. Majority of points cluster around the red line, especially for highly expressed genes. This is what we expect. There are some genes that have low average expression in removed cells (bottom right section under the red line) - these genes are typically indicative of poor quality cells (stressed, damaged, or empty droplets).\nBlue Line: Linear fit showing overall trend between gene expression in removed vs. kept. The relationship is linear, so this is good - our filtering did not introduce any outliers!\n\n\n\nCode\nload(paste0(proj_dir, \"/output/processed/02_SI_sobj_scale.Robj\"))\n\n# Determine which cells are kept\npass_qc &lt;- colnames(sobj) %in% colnames(sobj_post_df)\n\n# Add the pass_qc information to metadata\nsobj$pass_qc &lt;- pass_qc\n\nsave(sobj, file=\"/home/nsingh/sterile_inflammation/output/processed/02_SI_sobj_scale_pass_qc.Robj\")"
  },
  {
    "objectID": "analysis/02_quality_control.html#thresholds",
    "href": "analysis/02_quality_control.html#thresholds",
    "title": "Quality control",
    "section": "Thresholds",
    "text": "Thresholds\n\n\nCode\nload(paste0(proj_dir, \"/output/processed/02_SI_sobj_scale.Robj\"))\n\n# Thresholds\nfeature_lower &lt;- 300\nfeature_upper &lt;- 4000\ncount_lower &lt;- 500\ncount_upper &lt;- 20000\nmt_thresh &lt;- 5\nlog10genes_thresh &lt;- 0.8\n\n# Filtering results from the steps provided\nfilter_steps &lt;- data.frame(\n  Step = c(\n    \"Initial Cells\", \n    \"nFeature_RNA &gt; 300\", \n    \"nCount_RNA &gt; 500\",\n    \"log10genes_per_UMI &gt; 0.80\", \n    \"percent.mt &lt; 5\",\n    \"Doublets Removed\",\n    \"nFeature_RNA &lt; 4000\",\n    \"nCount_RNA &lt; 20000\"\n  ),\n  Remaining_Cells = c(46155, 39911, 39249, 39231, 36838, 34824, 34708, 34694),\n  Removed_Cells = c(NA, -6244, -662, -18, -2393, -2014, -116, -14)\n)\n\n# Add metadata column for \"Kept\" based on all thresholds\nsobj@meta.data &lt;- sobj@meta.data %&gt;%\n  mutate(\n    Kept = nFeature_RNA &gt; feature_lower & nFeature_RNA &lt; feature_upper &\n           nCount_RNA &gt; count_lower & nCount_RNA &lt; count_upper &\n           percent.mt &lt; mt_thresh & log10genes_per_UMI &gt; log10genes_thresh\n  )\n\n# Prepare data for the Counts vs Features plot\nplot_data &lt;- sobj@meta.data\n\n# Add filtering thresholds and removed cell info to the Counts vs Features plot\nexp_plot &lt;- ggplot(plot_data, aes(x = nCount_RNA, y = nFeature_RNA, colour = Kept)) +\n  geom_point(alpha = 0.3) +\n  geom_vline(xintercept = count_lower, linetype = \"dashed\", colour = \"#8DC63F\") +\n  geom_vline(xintercept = count_upper, linetype = \"dashed\", colour = \"#8DC63F\") +\n  geom_hline(yintercept = feature_lower, linetype = \"dashed\", colour = \"#7A52C7\") +\n  geom_hline(yintercept = feature_upper, linetype = \"dashed\", colour = \"#7A52C7\") +\n  annotate(\"text\", x = count_lower, y = Inf, label = paste(\"Removed:\", -filter_steps$Removed_Cells[3]),\n           angle = 90, vjust = -0.5, hjust = 1, colour = \"#8DC63F\") +\n  annotate(\"text\", x = count_upper, y = Inf, label = paste(\"Removed:\", -filter_steps$Removed_Cells[8]),\n           angle = 90, vjust = -0.5, hjust = 1, colour = \"#8DC63F\") +\n  annotate(\"text\", x = Inf, y = feature_lower, label = paste(\"Removed:\", -filter_steps$Removed_Cells[2]),\n           vjust = -0.5, hjust = 1, colour = \"#7A52C7\") +\n  annotate(\"text\", x = Inf, y = feature_upper, label = paste(\"Removed:\", -filter_steps$Removed_Cells[7]),\n           vjust = -0.5, hjust = 1, colour = \"#7A52C7\") +\n  scale_colour_manual(values = c(\"#EC008C\", \"#00ADEF\"), labels = c(\"Removed\", \"Kept\")) +\n  labs(x = \"nCount_RNA\", y = \"nFeature_RNA\", colour = \"\", title = \"nCount_RNA (300-20,000) vs nFeature_RNA (500-4000)\") +\n  theme_minimal()\n\n# Add filtering thresholds and removed cell info to the Mitochondrial percentage plot\nmt_plot &lt;- ggplot(plot_data, aes(x = percent.mt)) +\n  geom_histogram(bins = 100, fill = \"#7A52C7\", alpha = 0.7) +\n  geom_vline(xintercept = mt_thresh, linetype = \"dashed\", colour = \"#EC008C\") +\n  annotate(\"text\", x = 8, y = Inf, label = paste(\"Removed:\", -filter_steps$Removed_Cells[5]),\n           angle = 90, vjust = -0.5, hjust = 1, colour = \"#EC008C\") +\n  labs(x = \"Percentage mitochondrial\", y = \"Number of cells\", title = \"Mitochondrial content (&lt;5%)\") +\n  theme_minimal()\n\n# Add filtering thresholds and removed cell info to the log10 Genes per UMI plot\numi_plot &lt;- ggplot(plot_data, aes(x = log10genes_per_UMI)) +\n  geom_histogram(bins = 100, fill = \"#00ADEF\", alpha = 0.7) +\n  geom_vline(xintercept = log10genes_thresh, linetype = \"dashed\", colour = \"#EC008C\") +\n  annotate(\"text\", x = log10genes_thresh, y = Inf, label = paste(\"Removed:\", -filter_steps$Removed_Cells[4]),\n           angle = 90, vjust = -0.5, hjust = 1, colour = \"#EC008C\") +\n  labs(x = \"Log10 genes per UMI\", y = \"Number of cells\", title = \"Log10 genes per UMI (&lt;0.8)\") +\n  theme_minimal()\n\n# Use cowplot to add the annotation near the legend\np_doublets &lt;- ggdraw(p_doublets) + ggtitle(\"Doublets: removed 2014\")\n\n# Combine all plots into a single figure\nfig &lt;- plot_grid(\n  exp_plot, mt_plot, umi_plot, p_doublets,\n  labels = \"AUTO\", ncol = 2\n)\nfig"
  },
  {
    "objectID": "analysis/02_quality_control.html#validation-1",
    "href": "analysis/02_quality_control.html#validation-1",
    "title": "Quality control",
    "section": "Validation",
    "text": "Validation\n\n\nCode\nload(paste0(proj_dir, \"/output/processed/02_SI_sobj_scale_pass_qc.Robj\"))\nlibrary(ggrepel)\n\n# Determine which cells are kept\npass_qc &lt;- colnames(sobj) %in% colnames(sobj_post_df)\n\n# Separate counts for kept and lost cells\nlost_counts &lt;- as.matrix(sobj@assays[[\"RNA\"]]@layers[[\"counts\"]][, !pass_qc])\nkept_counts &lt;- as.matrix(sobj@assays[[\"RNA\"]]@layers[[\"counts\"]][, pass_qc])\n\n# Create a data frame for fold-change metrics\nkept_lost &lt;- tibble(\n  Gene     = rownames(sobj),\n  Lost     = rowMeans(lost_counts),\n  LostProp = rowSums(lost_counts &gt; 0) / ncol(lost_counts),\n  Kept     = rowMeans(kept_counts),\n  KeptProp = rowSums(kept_counts &gt; 0) / ncol(kept_counts),\n  LogFC    = log2((rowMeans(kept_counts) + 1) / (rowMeans(lost_counts) + 1))\n)\n\n# Select the top 10 genes highly expressed in removed cells (lowest LogFC)\ntop_removed_genes &lt;- kept_lost %&gt;%\n  arrange(LogFC) %&gt;%\n  slice_head(n = 10)\n\n# Select the top 10 genes highly expressed in kept cells (highest LogFC)\ntop_kept_genes &lt;- kept_lost %&gt;%\n  arrange(desc(LogFC)) %&gt;%\n  slice_head(n = 10)\n\n# Add a column to indicate highlighted genes\nkept_lost &lt;- kept_lost %&gt;%\n  mutate(\n    Highlight = ifelse(Gene %in% c(top_removed_genes$Gene, top_kept_genes$Gene), Gene, NA)\n  )\n\n# Plot with highlighted genes\nfc_plot &lt;- ggplot(kept_lost, aes(x = 0.5 * (Lost + Kept), y = LogFC, colour = LostProp - KeptProp)) +\n  geom_point(alpha = 0.3) +\n  geom_hline(yintercept = 0, colour = \"red\") +\n  scale_x_log10(labels = scales::number_format(accuracy = 0.0001)) +\n  scale_colour_viridis_c(name = \"Prop expressed (Removed) - Prop expressed (Kept)\") +\n  ggtitle(\"Fold-change between removed and kept cells\") +\n  xlab(\"0.5 * (Average expression (Kept) + Average expression (Removed))\") +\n  ylab(\"Predicted log2 fold-change (Removed / Kept)\") +\n  theme_minimal() +\n  theme(legend.position = \"bottom\") +\n  # Add labels for the top 10 genes\n  geom_text_repel(\n    data = filter(kept_lost, !is.na(Highlight)),\n    aes(label = Highlight),\n    max.overlaps = 10, colour = \"black\", size = 3\n  )\n\n# Create a table for top fold-change genes\nfc_table &lt;- kept_lost %&gt;%\n  select(Gene, LogFC) %&gt;%\n  arrange(-LogFC) %&gt;%\n  head(15) %&gt;%\n  tableGrob(rows = NULL, theme = ttheme_minimal())\n\nfeature_plots &lt;- list(\n  FeaturePlot(sobj_post_df, features = \"nCount_RNA\") +\n    scale_colour_viridis_c() +\n    ggtitle(\"nCount_RNA\") + NoAxes() + NoLegend(),\n  FeaturePlot(sobj_post_df, features = \"nFeature_RNA\") +\n    scale_colour_viridis_c() +\n    ggtitle(\"nFeature_RNA\") + \n    NoAxes() + NoLegend(),\n  FeaturePlot(sobj_post_df, features = \"percent.mt\") +\n    scale_colour_viridis_c() +\n    ggtitle(\"% mito\") +\n    NoAxes() + NoLegend(),\n  FeaturePlot(sobj_post_df, features = \"log10genes_per_UMI\") +\n    scale_colour_viridis_c() +\n    ggtitle(\"Log10 genes per UMI\") +\n    NoAxes() + NoLegend()\n)\n\n# Combine plots into a grid (2 columns)\numap_plot &lt;- wrap_plots(feature_plots, ncol = 2)\n\n# Combine fold-change plot and table\np1 &lt;- plot_grid(fc_plot, ncol = 1, labels = \"AUTO\")\n\n# Combine fold-change section with UMAP plots\nfig &lt;- plot_grid(p1, umap_plot, ncol = 2, labels = c(\"\", \"B\"),\n                 rel_heights = c(0.8, 1))\n\n# Display the figure\nfig"
  },
  {
    "objectID": "analysis/02_quality_control.html#parameters",
    "href": "analysis/02_quality_control.html#parameters",
    "title": "Quality control",
    "section": "Parameters",
    "text": "Parameters\nThis table describes parameters used and set in this document.\n\n\n\n\n\n\n\n\n\n\n\n\nParameter\nDescription\nCells_remaining\nThreshold\nCells_removed\n\n\n\n\nInitial Cells\nInitial number of cells before filtering\n46155\nNA\nNA\n\n\nnFeature_RNA\nFilter for cells with detected features above a minimum threshold\n39911\n&gt; 300\n6244\n\n\nnCount_RNA\nFilter for cells with total RNA counts above a minimum threshold\n39249\n&gt; 500\n662\n\n\nlog10genes_per_UMI\nFilter for cells with sufficient gene complexity (log10 genes per UMI)\n39231\n&gt; 0.80\n18\n\n\npercent.mt\nFilter for cells with mitochondrial percentage below a maximum threshold\n36838\n&lt; 5%\n2393\n\n\nDoublets\nRemove doublets identified using DoubletFinder\n34824\nN/A\n2014\n\n\nnFeature_RNA\nFilter for cells with detected features below a maximum threshold\n34708\n&lt; 4000\n116\n\n\nnCount_RNA\nFilter for cells with total RNA counts below a maximum threshold\n34694\n&lt; 20000\n14"
  },
  {
    "objectID": "analysis/02_quality_control.html#output-files",
    "href": "analysis/02_quality_control.html#output-files",
    "title": "Quality control",
    "section": "Output files",
    "text": "Output files\nThis table describes the output files produced by this document. Right click and Save Link As… to download the results (to be implemented).\n\n\nCode\nsaved_files &lt;- extract_saved_files(\"./analysis/02_quality_control.qmd\")\n#saved_files &lt;- saved_files[-c(1, 2), ]\nprint(saved_files)\nwrite.csv(saved_files, file = paste0(proj_dir, \"/output/data/02_SI_saved_files_summary.csv\"))\n\n\n\n\nCode\nsaved_files &lt;- read.csv(file = paste0(proj_dir, \"/output/data/02_SI_saved_files_summary.csv\"))\nparams &lt;- jsonlite::toJSON(saved_files, pretty = TRUE)\nknitr::kable(jsonlite::fromJSON(params))\n\n\n\n\n\n\n\n\n\n\n\nX\nFile\nDirectory\nDescription\n\n\n\n\n1\nselected\nfile=here::here(output/processed/02_SI_selected.Robj)\nSCE obj, add lib size, normalize\n\n\n2\nsobj\nfile=/home/nsingh/sterile_inflammation/output/processed/02_SI_sobj.Robj\ninitial SO, unfiltered\n\n\n3\nsobj\nfile=/home/nsingh/sterile_inflammation/output/processed/02_SI_sobj_scale.Robj\ninitial SO; unfiltered, scaled\n\n\n4\nfiltered_sobj\nfile=./output/processed/02_SI_sobj_qc.Robj\nSO post filtering #1\n\n\n5\nfiltered_sobj\nfile=/home/nsingh/sterile_inflammation/output/processed/02_SI_sobj_df.Robj\nSO post doublet finder\n\n\n6\nsobj_post_df\nfile=./output/processed/02_SI_sobj_post_df.Robj\nSO post filtering #2\n\n\n7\nvp\nfile = ./output/processed/02_SI_variancePartition.Robj\nvariance partition on qc metrics\n\n\n8\nsobj\nfile=/home/nsingh/sterile_inflammation/output/processed/02_SI_sobj_scale_pass_qc.Robj\nintial SO, add metadata whether cells passed qc"
  },
  {
    "objectID": "analysis/01_empty_droplets.html",
    "href": "analysis/01_empty_droplets.html",
    "title": "Empty droplets",
    "section": "",
    "text": "In this document we are going to read in the unfiltered counts matrix produced by Cell Ranger and determine which of those droplets contain cells using the DropletUtils package.\n\n\nCode\nsample_names &lt;- c(\"PVM_0h\", \"PVEU_0h\", \"PVM_4h\", \n                  \"PVEU_4h\", \"PVM_7h\", \"PVEU_7h\")\n\n# Make an sce object of raw barcode counts\n#file_paths &lt;- file.path(\"data/cellranger_results\",sample_names,\"raw_feature_bc_matrix\")\nlist_of_files &lt;- str_c(\"~/Desktop/sterile_inflammation/data/cellranger_results/\",sample_names,\n                   \"/raw_feature_bc_matrix\")\nraw &lt;- read10xCounts(list_of_files, col.names=TRUE)\n\n# Add sample-specific prefixes to the raw SCE object\nsample_prefixes &lt;- rep(sample_names, sapply(list_of_files, function(f) {\n  ncol(read10xCounts(f))\n}))\n\ncolnames(raw) &lt;- paste0(sample_prefixes, \"_\", colnames(raw))\ncolnames(raw) &lt;- gsub(\"_1_\", \"_\", colnames(raw))\n\n# Repeat for filtered SCE object\nlist_of_files &lt;- str_c(\"~/Desktop/sterile_inflammation/data/cellranger_results/\", sample_names,\n                       \"/filtered_feature_bc_matrix\")\n\nfiltered &lt;- read10xCounts(list_of_files, col.names = TRUE)\n\n# Add sample-specific prefixes to the filtered SCE object\nsample_prefixes &lt;- rep(sample_names, sapply(list_of_files, function(f) {\n  ncol(read10xCounts(f))\n}))\n\ncolnames(filtered) &lt;- paste0(sample_prefixes, \"_\", colnames(filtered))\ncolnames(filtered) &lt;- gsub(\"_1_\", \"_\", colnames(filtered))\n\n# Verify the updated barcodes\nhead(colnames(raw))\n\n\n[1] \"PVM_0h_AAACCTGAGAAACCTA-1\" \"PVM_0h_AAACCTGAGAACAACT-1\"\n[3] \"PVM_0h_AAACCTGAGAACTCGG-1\" \"PVM_0h_AAACCTGAGAAGATTC-1\"\n[5] \"PVM_0h_AAACCTGAGAAGCCCA-1\" \"PVM_0h_AAACCTGAGAATTCCC-1\"\n\n\nCode\nhead(colnames(filtered))\n\n\n[1] \"PVM_0h_AAACCTGGTGCTAGCC-1\" \"PVM_0h_AAACCTGTCACATACG-1\"\n[3] \"PVM_0h_AAACCTGTCCTTGGTC-1\" \"PVM_0h_AAACGGGAGACAAGCC-1\"\n[5] \"PVM_0h_AAACGGGAGCCCGAAA-1\" \"PVM_0h_AAACGGGAGCCTATGT-1\"\n\n\nCode\n# Extract barcodes from raw and filtered SCE objects\nraw_barcodes &lt;- colnames(raw)       # Barcodes in the raw SCE\nfiltered_barcodes &lt;- colnames(filtered) # Barcodes in the filtered SCE\n\n# Update CellRangerFilt in the colData of raw\ncolData(raw)$CellRangerFilt &lt;- raw_barcodes %in% filtered_barcodes\n\n# # Verify the result\n# table(colData(raw)$CellRangerFilt)\n# #   FALSE    TRUE \n# # 2029157   39278 \n# \n# nrow(raw)\n# # [1] 32285\n# ncol(raw)\n# # [1] 2068435\n\n\nThe raw object now contains the raw counts and metadata, with an additional column (CellRangerFilt) marking which cells passed Cell Ranger’s initial filtering. The raw dataset has 32285 features and 2068435 droplets at this point.\n\n\nCode\nraw &lt;- raw[Matrix::rowSums(counts(raw)) &gt; 0, Matrix::colSums(counts(raw)) &gt; 0]\n\n\nThe raw object is now pruned to exclude: - Genes that are not expressed in any cell. - Droplets that do not contain any counts (empty droplets).\nAfter removing all zero features and droplets the dataset has 25634 features and 1445128 droplets."
  },
  {
    "objectID": "analysis/01_empty_droplets.html#parameters",
    "href": "analysis/01_empty_droplets.html#parameters",
    "title": "Empty droplets",
    "section": "Parameters",
    "text": "Parameters\nThis table describes parameters used and set in this document.\n\n\nCode\nparams &lt;- list(\n    list(\n        Parameter = \"n_droplets\",\n        Value = ncol(raw),\n        Description = \"Number of droplets in the raw dataset\"\n    ),\n    list(\n        Parameter = \"empty_thresh\",\n        Value = empty_thresh,\n        Description = \"Droplets with less than this many counts are empty\"\n    ),\n    list(\n        Parameter = \"emp_iters\",\n        Value = emp_iters,\n        Description = \"Number of iterations for EmptyDrops p-values\"\n    ),\n    list(\n        Parameter = \"emp_fdr\",\n        Value = emp_fdr,\n        Description = \"FDR cutoff for EmptyDrops\"\n    ),\n    list(\n        Parameter = \"n_cellranger\",\n        Value = sum(colData(raw)$CellRangerFilt),\n        Description = \"Number of cells selected by the Cell Ranger v3 method\"\n    ),\n    list(\n        Parameter = \"n_empdrops\",\n        Value = sum(colData(raw)$EmpDropsFilt),\n        Description = \"Number of cells selected by the EmptyDrops method\"\n    ),\n    list(\n        Parameter = \"n_cells\",\n        Value = ncol(selected),\n        Description = \"Number of cells selected\"\n    )\n)\n\nparams &lt;- jsonlite::toJSON(params, pretty = TRUE)\nknitr::kable(jsonlite::fromJSON(params))\n\n\n\n\n\nParameter\nValue\nDescription\n\n\n\n\nn_droplets\n1445128\nNumber o….\n\n\nempty_thresh\n100\nDroplets….\n\n\nemp_iters\n60000\nNumber o….\n\n\nemp_fdr\n0.01\nFDR cuto….\n\n\nn_cellranger\n39278\nNumber o….\n\n\nn_empdrops\n45819\nNumber o….\n\n\nn_cells\n46155\nNumber o….\n\n\n\n\n\nCode\n# json_table &lt;- jsonlite::fromJSON(params)\n# \n# knitr::kable(json_table, format = \"html\") %&gt;%\n#   kable_styling(bootstrap_options = \"striped\", full_width = FALSE, position = \"left\") %&gt;%\n#   scroll_box(width = \"100%\", height = \"400px\")"
  },
  {
    "objectID": "analysis/01_empty_droplets.html#output-files",
    "href": "analysis/01_empty_droplets.html#output-files",
    "title": "Empty droplets",
    "section": "Output files",
    "text": "Output files\nThis table describes the output files produced by this document. Right click and Save Link As… to download the results (to be implemented).\n\n\nCode\nsave(selected, file=here::here(\"output/processed/01_SI_selected.Robj\"))\n\n\n\n\nCode\nreadr::write_lines(params, here::here(\"output\", DOCNAME, \"parameters.json\"))\n\n# Assuming all calls return single strings\nfile_links &lt;- c(\n    getDownloadLink(\"parameters.json\", DOCNAME),\n    getDownloadLink(\"01_SI_1_barcodes_kept.png\", DOCNAME),\n    getDownloadLink(\"01_SI_2_empty_droplets_distribution.png\", DOCNAME),\n    getDownloadLink(\"01_SI_3_barcodes_negative_prob.png\", DOCNAME),\n    getDownloadLink(\"01_SI_4_compare_methods.png\", DOCNAME),\n    getDownloadLink(\"01_SI_selected.Robj\", DOCNAME)\n)\n\n# Create data frame\nresults_df &lt;- data.frame(\n    File = file_links,\n    Description = c(\n        \"Parameters set and used in this analysis\",\n        \"Barcodes kept in CellRanger V3 (PNG)\",\n        \"Distribution of empty droplets (PNG)\",\n        \"Negative log probability of barcode counts (PNG)\",\n        \"Compare both methods (PNG)\",\n        \"A SingleCellExperiment object of droplets that were called as cells by either Cell ranger v3 or Empty drops\"\n    ),\n    stringsAsFactors = FALSE  # Optional: Prevent factors if not needed\n)\n\n# Display table using knitr::kable\nknitr::kable(results_df)\n\n\n\n\n\nFile\nDescription\n\n\n\n\nparameters.json\nParameters set and used in this analysis\n\n\n01_SI_1_barcodes_kept.png\nBarcodes kept in CellRanger V3 (PNG)\n\n\n01_SI_2_empty_droplets_distribution.png\nDistribution of empty droplets (PNG)\n\n\n01_SI_3_barcodes_negative_prob.png\nNegative log probability of barcode counts (PNG)\n\n\n01_SI_4_compare_methods.png\nCompare both methods (PNG)\n\n\n01_SI_selected.Robj\nA SingleCellExperiment object of droplets that were called as cells by either Cell ranger v3 or Empty drops"
  },
  {
    "objectID": "analysis/01_empty_droplets.html#session-information",
    "href": "analysis/01_empty_droplets.html#session-information",
    "title": "Empty droplets",
    "section": "Session information",
    "text": "Session information\n\n\nCode\ndevtools::session_info()\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.3 (2024-02-29)\n os       macOS Sonoma 14.6.1\n system   x86_64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/Vienna\n date     2025-01-01\n pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n ! package              * version   date (UTC) lib source\n P abind                  1.4-8     2024-09-12 [?] CRAN (R 4.3.3)\n   beachmat               2.18.1    2024-02-14 [1] Bioconductor 3.18 (R 4.3.2)\n   Biobase              * 2.62.0    2023-10-24 [1] Bioconductor\n   BiocGenerics         * 0.48.1    2023-11-01 [1] Bioconductor\n P BiocManager            1.30.25   2024-08-28 [?] CRAN (R 4.3.3)\n   BiocParallel           1.36.0    2023-10-24 [1] Bioconductor\n P bitops                 1.0-9     2024-10-03 [?] CRAN (R 4.3.3)\n P cachem                 1.1.0     2024-05-16 [?] CRAN (R 4.3.3)\n   cli                    3.6.3     2024-06-21 [1] RSPM (R 4.3.0)\n P codetools              0.2-19    2023-02-01 [?] CRAN (R 4.3.3)\n P colorspace             2.1-1     2024-07-26 [?] CRAN (R 4.3.3)\n P cowplot              * 1.1.3     2024-01-22 [?] CRAN (R 4.3.2)\n P crayon                 1.5.3     2024-06-20 [?] CRAN (R 4.3.3)\n   DelayedArray           0.28.0    2023-10-24 [1] Bioconductor\n   DelayedMatrixStats     1.24.0    2023-10-24 [1] Bioconductor\n P devtools               2.4.5     2022-10-11 [?] CRAN (R 4.3.0)\n   digest                 0.6.37    2024-08-19 [1] RSPM (R 4.3.0)\n P dplyr                * 1.1.4     2023-11-17 [?] CRAN (R 4.3.0)\n P dqrng                  0.4.1     2024-05-28 [?] RSPM\n   DropletUtils         * 1.22.0    2023-10-24 [1] Bioconductor\n   edgeR                  4.0.16    2024-02-18 [1] Bioconductor 3.18 (R 4.3.2)\n P ellipsis               0.3.2     2021-04-29 [?] CRAN (R 4.3.0)\n   evaluate               1.0.1     2024-10-10 [1] RSPM (R 4.3.0)\n P fastmap                1.2.0     2024-05-15 [?] CRAN (R 4.3.3)\n P forcats              * 1.0.0     2023-01-29 [?] RSPM\n   fs                     1.6.5     2024-10-30 [1] RSPM (R 4.3.0)\n P generics               0.1.3     2022-07-05 [?] CRAN (R 4.3.0)\n   GenomeInfoDb         * 1.38.8    2024-03-15 [1] Bioconductor 3.18 (R 4.3.3)\n   GenomeInfoDbData       1.2.11    2024-12-25 [1] Bioconductor\n   GenomicRanges        * 1.54.1    2023-10-29 [1] Bioconductor\n P ggplot2              * 3.5.1     2024-04-23 [?] CRAN (R 4.3.2)\n   glue                   1.8.0     2024-09-30 [1] RSPM (R 4.3.0)\n P gridExtra              2.3       2017-09-09 [?] CRAN (R 4.3.0)\n P gtable                 0.3.6     2024-10-25 [?] CRAN (R 4.3.3)\n   HDF5Array              1.30.1    2024-03-06 [1] Bioconductor 3.18 (R 4.3.3)\n P here                 * 1.0.1     2020-12-13 [?] CRAN (R 4.3.0)\n P hms                    1.1.3     2023-03-21 [?] CRAN (R 4.3.0)\n P htmltools              0.5.8.1   2024-04-04 [?] CRAN (R 4.3.2)\n P htmlwidgets            1.6.4     2023-12-06 [?] CRAN (R 4.3.0)\n P httpuv                 1.6.15    2024-03-26 [?] CRAN (R 4.3.2)\n   IRanges              * 2.36.0    2023-10-24 [1] Bioconductor\n   jsonlite               1.8.9     2024-09-20 [1] RSPM (R 4.3.0)\n P kableExtra           * 1.4.0     2024-01-24 [?] RSPM\n   knitr                  1.49      2024-11-08 [1] RSPM (R 4.3.0)\n P later                  1.4.1     2024-11-27 [?] RSPM\n P lattice                0.22-5    2023-10-24 [?] CRAN (R 4.3.3)\n P lifecycle              1.0.4     2023-11-07 [?] CRAN (R 4.3.0)\n   limma                  3.58.1    2023-10-31 [1] Bioconductor\n   locfit                 1.5-9.10  2024-06-24 [1] RSPM (R 4.3.0)\n P lubridate            * 1.9.4     2024-12-08 [?] RSPM\n   magrittr               2.0.3     2022-03-30 [1] RSPM (R 4.3.0)\n P Matrix               * 1.6-5     2024-01-11 [?] CRAN (R 4.3.3)\n   MatrixGenerics       * 1.14.0    2023-10-24 [1] Bioconductor\n P matrixStats          * 1.4.1     2024-09-08 [?] CRAN (R 4.3.3)\n P memoise                2.0.1     2021-11-26 [?] CRAN (R 4.3.0)\n P mime                   0.12      2021-09-28 [?] CRAN (R 4.3.0)\n P miniUI                 0.1.1.1   2018-05-18 [?] CRAN (R 4.3.0)\n P munsell                0.5.1     2024-04-01 [?] CRAN (R 4.3.2)\n P pillar                 1.10.0    2024-12-17 [?] RSPM\n P pkgbuild               1.4.5     2024-10-28 [?] CRAN (R 4.3.3)\n P pkgconfig              2.0.3     2019-09-22 [?] CRAN (R 4.3.0)\n P pkgload                1.4.0     2024-06-28 [?] RSPM\n P plyr                   1.8.9     2023-10-02 [?] CRAN (R 4.3.0)\n P profvis                0.4.0     2024-09-20 [?] CRAN (R 4.3.3)\n P promises               1.3.2     2024-11-28 [?] RSPM\n P purrr                * 1.0.2     2023-08-10 [?] CRAN (R 4.3.0)\n   R.methodsS3            1.8.2     2022-06-13 [1] RSPM (R 4.3.0)\n   R.oo                   1.27.0    2024-11-01 [1] RSPM (R 4.3.0)\n   R.utils                2.12.3    2023-11-18 [1] RSPM (R 4.3.0)\n P R6                     2.5.1     2021-08-19 [?] CRAN (R 4.3.0)\n P Rcpp                   1.0.13-1  2024-11-02 [?] CRAN (R 4.3.3)\n   RCurl                  1.98-1.16 2024-07-11 [1] RSPM (R 4.3.0)\n P readr                * 2.1.5     2024-01-10 [?] RSPM\n P remotes                2.5.0     2024-03-17 [?] RSPM\n   renv                   1.0.11    2024-10-12 [1] RSPM (R 4.3.0)\n   rhdf5                  2.46.1    2023-11-29 [1] Bioconductor\n   rhdf5filters           1.14.1    2023-11-06 [1] Bioconductor\n   Rhdf5lib               1.24.2    2024-02-07 [1] Bioconductor 3.18 (R 4.3.2)\n   rlang                  1.1.4     2024-06-04 [1] RSPM (R 4.3.0)\n   rmarkdown              2.29      2024-11-04 [1] RSPM (R 4.3.0)\n P rprojroot              2.0.4     2023-11-05 [?] CRAN (R 4.3.0)\n P rstudioapi             0.17.1    2024-10-22 [?] CRAN (R 4.3.3)\n   S4Arrays               1.2.1     2024-03-06 [1] Bioconductor 3.18 (R 4.3.3)\n   S4Vectors            * 0.40.2    2023-11-23 [1] Bioconductor\n P scales                 1.3.0     2023-11-28 [?] CRAN (R 4.3.0)\n   scuttle                1.12.0    2023-10-24 [1] Bioconductor\n P sessioninfo            1.2.2     2021-12-06 [?] CRAN (R 4.3.0)\n P shiny                  1.10.0    2024-12-14 [?] RSPM\n   SingleCellExperiment * 1.24.0    2023-10-24 [1] Bioconductor\n   SparseArray            1.2.4     2024-02-11 [1] Bioconductor 3.18 (R 4.3.2)\n   sparseMatrixStats      1.14.0    2023-10-24 [1] Bioconductor\n   statmod                1.5.0     2023-01-06 [1] RSPM (R 4.3.0)\n P stringi                1.8.4     2024-05-06 [?] CRAN (R 4.3.2)\n   stringr              * 1.5.1     2023-11-14 [1] RSPM (R 4.3.0)\n   SummarizedExperiment * 1.32.0    2023-10-24 [1] Bioconductor\n P svglite                2.1.3     2023-12-08 [?] RSPM\n P systemfonts            1.1.0     2024-05-15 [?] RSPM\n P tibble               * 3.2.1     2023-03-20 [?] CRAN (R 4.3.0)\n P tidyr                * 1.3.1     2024-01-24 [?] CRAN (R 4.3.2)\n P tidyselect             1.2.1     2024-03-11 [?] CRAN (R 4.3.2)\n P tidyverse            * 2.0.0     2023-02-22 [?] CRAN (R 4.3.0)\n P timechange             0.3.0     2024-01-18 [?] CRAN (R 4.3.0)\n P tzdb                   0.4.0     2023-05-12 [?] CRAN (R 4.3.0)\n P UpSetR               * 1.4.0     2019-05-22 [?] CRAN (R 4.3.0)\n P urlchecker             1.0.1     2021-11-30 [?] CRAN (R 4.3.0)\n P usethis                3.1.0     2024-11-26 [?] CRAN (R 4.3.3)\n P vctrs                  0.6.5     2023-12-01 [?] CRAN (R 4.3.0)\n P viridisLite            0.4.2     2023-05-02 [?] CRAN (R 4.3.0)\n P withr                  3.0.2     2024-10-28 [?] CRAN (R 4.3.3)\n   xfun                   0.49      2024-10-31 [1] RSPM (R 4.3.0)\n P xml2                   1.3.6     2023-12-04 [?] CRAN (R 4.3.0)\n P xtable                 1.8-4     2019-04-21 [?] CRAN (R 4.3.0)\n   XVector                0.42.0    2023-10-24 [1] Bioconductor\n   yaml                   2.3.10    2024-07-26 [1] RSPM (R 4.3.0)\n   zlibbioc               1.48.2    2024-03-13 [1] Bioconductor 3.18 (R 4.3.3)\n\n [1] /Users/nami/Desktop/sterile_inflammation/renv/library/R-4.3/x86_64-apple-darwin20\n [2] /Users/nami/Library/Caches/org.R-project.R/R/renv/sandbox/R-4.3/x86_64-apple-darwin20/b06620f4\n\n P ── Loaded and on-disk path mismatch.\n\n──────────────────────────────────────────────────────────────────────────────"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "This wesbite displays the analysis code and results for the sterile inflammation project in collaboration with Dr. Shweta Tikoo at the Deaprtment of Dermatology at the MedUni Wien.\nThe project aims to define changes in transcriptional landscape of stromal cells and leukocytes post sterile inflammation. These cells coordinate the recruitment of diverse immune cell subsets from circulation to the inflammed tissue to restrict inflammation and promote tissue repair.\nThe samples consist of FACS sorted cells from murine cremaster tissue under homeostasis or post-TNFa treatment at two different time points. The cells were then sequenced after cDNA libraries preparation.\nThe analysis shown here focuses on the decisions that were made during analysis and demonstrates a range of tools that can be used for various tasks."
  }
]